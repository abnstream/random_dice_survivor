<!DOCTYPE html>
<html lang="ja">
<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ²</text></svg>">
<head>
    <meta charset="UTF-8">
    <title>Dice Survivors</title>
    <style>
        :root {
            --bg-color: #222;
            --panel-bg: #111;
            --text-color: #fff;
            --border-color: #fff;
            --accent-red: #e74c3c;
            --accent-green: #2ecc71;
            --accent-blue: #3498db;
            --accent-yellow: #f1c40f;
            --accent-purple: #9b59b6;
            --accent-cyan: #1abc9c;
            --pip-color: #333;
            --pip-red: #e74c3c;
            
            --container-width: 1280px;
            --container-height: 720px;
            --top-bar-height: 90px;
            --sidebar-width: 260px;
        }

        body {
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: 'Segoe UI', 'Meiryo', sans-serif;
            color: var(--text-color);
            user-select: none;
            overflow: hidden;
        }

        #game-container {
            width: var(--container-width);
            height: var(--container-height);
            background-color: var(--panel-bg);
            display: grid;
            grid-template-rows: var(--top-bar-height) 1fr;
            grid-template-columns: var(--sidebar-width) 1fr;
            padding: 15px;
            box-sizing: border-box;
            gap: 15px;
            box-shadow: 0 0 40px rgba(0,0,0,0.5);
            position: relative;
        }

        /* --- ä¸Šéƒ¨ãƒãƒ¼ --- */
        #top-bar {
            grid-row: 1;
            grid-column: 1 / 3;
            display: flex;
            align-items: center;
            gap: 30px;
        }

        #dice-container {
            display: flex;
            gap: 12px;
            padding: 5px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            margin-right: auto;
        }

        .dice {
            width: 56px;
            height: 56px;
            background-color: #fdfdfd;
            border-radius: 10px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.1), 0 4px 6px rgba(0,0,0,0.3);
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            padding: 6px;
            box-sizing: border-box;
            gap: 2px;
            transition: transform 0.2s;
            flex-shrink: 0;
            color: black; /* æ•°å­—è¡¨ç¤ºç”¨ */
            font-weight: bold;
            font-size: 24px;
            place-items: center;
        }
        
        .pip {
            background-color: var(--pip-color);
            border-radius: 50%;
            width: 10px;
            height: 10px;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.5);
        }

        /* Face Layouts */
        .face-1 { display: flex; justify-content: center; align-items: center; }
        .face-1 .pip { width: 24px; height: 24px; background-color: var(--pip-red); }
        .face-2 .pip:nth-child(1) { grid-area: 1 / 3; } .face-2 .pip:nth-child(2) { grid-area: 3 / 1; }
        .face-3 .pip:nth-child(1) { grid-area: 1 / 3; } .face-3 .pip:nth-child(2) { grid-area: 2 / 2; } .face-3 .pip:nth-child(3) { grid-area: 3 / 1; }
        .face-4 .pip:nth-child(1) { grid-area: 1 / 1; } .face-4 .pip:nth-child(2) { grid-area: 1 / 3; } .face-4 .pip:nth-child(3) { grid-area: 3 / 1; } .face-4 .pip:nth-child(4) { grid-area: 3 / 3; }
        .face-5 .pip:nth-child(1) { grid-area: 1 / 1; } .face-5 .pip:nth-child(2) { grid-area: 1 / 3; } .face-5 .pip:nth-child(3) { grid-area: 2 / 2; } .face-5 .pip:nth-child(4) { grid-area: 3 / 1; } .face-5 .pip:nth-child(5) { grid-area: 3 / 3; }
        .face-6 .pip:nth-child(1) { grid-area: 1 / 1; } .face-6 .pip:nth-child(2) { grid-area: 1 / 3; } .face-6 .pip:nth-child(3) { grid-area: 2 / 1; } .face-6 .pip:nth-child(4) { grid-area: 2 / 3; } .face-6 .pip:nth-child(5) { grid-area: 3 / 1; } .face-6 .pip:nth-child(6) { grid-area: 3 / 3; }

        .rolling { animation: shake 0.2s infinite; filter: blur(1px); }
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            50% { transform: translate(-1px, -2px) rotate(-5deg); }
            100% { transform: translate(1px, -1px) rotate(5deg); }
        }

        /* Status Bar */
        .status-group { display: flex; flex-direction: column; width: 320px; }
        .status-header-row { display: flex; justify-content: space-between; align-items: flex-end; margin-bottom: 4px; }
        .status-label { font-size: 16px; font-weight: bold; letter-spacing: 1px; color: #ccc; }
        .status-value { font-size: 14px; color: var(--text-color); font-family: monospace; }
        .bar-bg { width: 100%; height: 20px; background: #333; border: 1px solid #666; position: relative; }
        #level-bar-fill { height: 100%; background: linear-gradient(90deg, #2ecc71, #27ae60); width: 0%; transition: width 0.2s; }
        #wave-bar-fill { height: 100%; background: linear-gradient(90deg, #e74c3c, #c0392b); width: 100%; }

        /* --- å·¦ã‚µã‚¤ãƒ‰ãƒãƒ¼ (ã‚¹ã‚­ãƒ«ä¸€è¦§) --- */
        #left-sidebar {
            grid-row: 2;
            grid-column: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow: hidden;
        }
        #skill-list-container {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding-right: 5px;
        }
        #skill-list-container::-webkit-scrollbar { width: 6px; }
        #skill-list-container::-webkit-scrollbar-track { background: #222; }
        #skill-list-container::-webkit-scrollbar-thumb { background: #555; border-radius: 3px; }

        .skill-card {
            background: #eee;
            color: #222;
            padding: 8px;
            display: flex;
            align-items: center;
            border-radius: 6px;
            min-height: 72px;
            box-sizing: border-box;
            border-left: 5px solid #aaa;
            position: relative;
        }
        .skill-card .dice { transform: scale(0.65); margin-right: 2px; border: 1px solid #ccc; }
        .skill-info { display: flex; flex-direction: column; justify-content: center; width: 100%; }
        .skill-title { font-weight: bold; font-size: 14px; color: #000; margin-bottom: 2px; display: flex; justify-content: space-between;}
        .skill-level { font-size: 12px; background: #333; color: white; padding: 1px 4px; border-radius: 4px; }
        .skill-desc { font-size: 10px; color: #555; line-height: 1.2; }

        /* HPè¡¨ç¤º */
        #hp-container {
            flex-shrink: 0;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #444;
        }
        .hp-header { display: flex; justify-content: space-between; align-items: baseline; margin-bottom: 5px; font-size: 14px; font-weight: bold; }
        #hp-text { color: var(--accent-green); font-family: monospace; font-size: 16px; }
        .hp-bar-bg { width: 100%; height: 15px; background: #333; border: 1px solid #fff; }
        #hp-bar-fill { width: 100%; height: 100%; background: var(--accent-green); transition: width 0.1s; }

        /* --- ã‚²ãƒ¼ãƒ ã‚¨ãƒªã‚¢ --- */
        #game-viewport-wrapper {
            grid-row: 2;
            grid-column: 2;
            position: relative;
            border: 4px solid var(--border-color);
            box-sizing: border-box;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        canvas { display: block; }

        /* ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ (ãƒãƒ¼ã‚º, ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼, ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—) */
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(4px);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 100;
            color: white;
        }
        #game-over-screen { background: rgba(50,0,0,0.9); z-index: 101; }
        h1 { margin: 0 0 20px 0; letter-spacing: 5px; font-size: 40px; }

        /* ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ç”»é¢ */
        #level-up-screen { z-index: 110; }
        .level-up-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 80%;
            max-width: 800px;
        }
        .level-up-title { font-size: 32px; font-weight: bold; margin-bottom: 30px; color: var(--accent-green); text-shadow: 0 0 10px var(--accent-green); }
        .level-up-instruction { font-size: 18px; margin-bottom: 20px; }

        /* 3æŠã‚«ãƒ¼ãƒ‰ */
        .card-container {
            display: flex;
            gap: 20px;
            width: 100%;
            justify-content: center;
        }
        .choice-card {
            background: #222;
            border: 2px solid #fff;
            border-radius: 8px;
            width: 220px;
            height: 300px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s;
        }
        .choice-card:hover { transform: scale(1.05); background: #333; border-color: var(--accent-green); }
        .choice-name { font-size: 20px; font-weight: bold; margin: 15px 0; text-align: center; border-bottom: 1px solid #555; width: 100%; padding-bottom: 10px; }
        .choice-desc { font-size: 14px; text-align: center; color: #ccc; flex: 1; }
        .choice-bonus { font-size: 12px; color: var(--accent-yellow); margin-top: 10px; }

        /* ã‚¹ãƒ­ãƒƒãƒˆé¸æŠç”»é¢ */
        #slot-select-container { display: none; flex-direction: column; align-items: center; width: 100%; }
        .slot-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 20px;
        }
        .slot-btn {
            background: #eee;
            color: #222;
            border: 2px solid #999;
            border-radius: 6px;
            padding: 10px;
            width: 350px;
            display: flex;
            align-items: center;
            cursor: pointer;
            transition: 0.2s;
            position: relative;
        }
        .slot-btn:hover { background: #fff; border-color: var(--accent-green); }
        .slot-btn .dice { transform: scale(0.6); margin-right: 10px; border: 1px solid #ccc; }
        .slot-info { display: flex; flex-direction: column; }
        .slot-preview { position: absolute; right: 10px; font-weight: bold; color: var(--accent-red); font-size: 18px; }

        /* --- ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ --- */
        #title-screen {
            display: flex; /* åˆæœŸè¡¨ç¤º */
            z-index: 200;
            background: rgba(0,0,0,0.9);
        }
        
        .game-title {
            font-size: 72px;
            color: #e74c3c;
            text-shadow: 0 0 20px #c0392b;
            margin-bottom: 20px;
            font-family: 'Segoe UI', sans-serif;
            font-weight: 900;
            letter-spacing: 5px;
        }
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 30px;
        }
        .menu-btn {
            padding: 15px 60px;
            font-size: 24px;
            background: #222;
            color: white;
            border: 2px solid #555;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
            font-family: monospace;
        }
        .menu-btn:hover {
            background: #333;
            border-color: #2ecc71;
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(46, 204, 113, 0.4);
        }
        .credit-display {
            font-size: 20px;
            color: #f1c40f;
            font-family: monospace;
            border: 1px solid #f1c40f;
            padding: 10px 20px;
            border-radius: 30px;
            background: rgba(241, 196, 15, 0.1);
        }
        
        /* ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç”»é¢ã®ãƒœã‚¿ãƒ³ç”¨ */
        .restart-btn {
            margin-top: 20px;
            padding: 10px 30px;
            font-size: 18px;
            background: transparent;
            color: #fff;
            border: 1px solid #fff;
            cursor: pointer;
        }
        .restart-btn:hover { background: #fff; color: #000; }

        /* --- ã‚·ãƒ§ãƒƒãƒ—ç”»é¢ --- */
        /* --- ã‚·ãƒ§ãƒƒãƒ—ç”»é¢ --- */
        #shop-screen {
            display: none;
            flex-direction: column;
            align-items: center;
            /* â˜…å¤‰æ›´: ä¸Šä¸‹ä¸­å¤®æƒãˆã‚’è§£é™¤ã—ã€ä¸Šè©°ã‚ã«ã™ã‚‹ã“ã¨ã§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«åˆ‡ã‚Œã‚’é˜²ã */
            justify-content: flex-start; 
            background: rgba(10, 10, 20, 0.95);
            z-index: 210;
            overflow-y: auto;
            /* ä¸Šä¸‹ã®ä½™ç™½ã‚’ç¢ºä¿ */
            padding: 60px 40px; 
            box-sizing: border-box;
        }
        .shop-header {
            width: 100%;
            max-width: 900px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            border-bottom: 2px solid #555;
            padding-bottom: 20px;
        }
        .shop-title { font-size: 48px; font-weight: bold; color: #f1c40f; }
        .shop-credits { font-size: 24px; color: #fff; font-family: monospace; }
        
        .shop-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            width: 100%;
            max-width: 900px;
        }
        .shop-card {
            background: #222;
            border: 2px solid #444;
            border-radius: 8px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .shop-card-header { display: flex; justify-content: space-between; align-items: baseline; }
        .shop-item-name { font-size: 20px; font-weight: bold; color: var(--accent-green); }
        .shop-item-level { font-size: 14px; color: #aaa; }
        .shop-item-desc { font-size: 14px; color: #ccc; flex: 1; }
        .shop-buy-btn {
            padding: 10px;
            background: var(--accent-blue);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .shop-buy-btn:hover { background: #2980b9; }
        .shop-buy-btn:disabled { background: #555; color: #888; cursor: not-allowed; }
        .shop-cost { font-family: monospace; }
        
        .back-btn {
            margin-top: 30px;
            padding: 10px 40px;
            font-size: 20px;
            background: transparent;
            border: 2px solid #fff;
            color: #fff;
            cursor: pointer;
        }
        .back-btn:hover { background: #fff; color: #000; }

        /* éŸ³é‡ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .volume-control {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
            font-family: monospace;
            color: #ccc;
        }
        input[type=range] {
            -webkit-appearance: none;
            background: transparent;
            width: 200px;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 8px;
            background: #444;
            border-radius: 4px;
            border: 1px solid #777;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 10px;
            border-radius: 2px;
            background: var(--accent-green);
            cursor: pointer;
            margin-top: -7px; /* 
            
            ãƒˆãƒ©ãƒƒã‚¯ã®ä¸­å¤®ã«åˆã‚ã›ã‚‹ */
        }

        /* --- ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢å°‚ç”¨ã‚¹ã‚¿ã‚¤ãƒ« --- */
        #ending-screen {
            background: linear-gradient(135deg, rgba(20,0,50,0.95), rgba(0,0,20,0.95)); /* ã¡ã‚‡ã£ã¨ãƒªãƒƒãƒãªèƒŒæ™¯è‰² */
        }
        .ending-title {
            font-size: 60px;
            background: linear-gradient(to bottom, #f1c40f, #e67e22, #f1c40f);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(241, 196, 15, 0.6);
            margin-bottom: 10px;
            animation: glow 2s ease-in-out infinite alternate;
        }
        @keyframes glow {
            from { text-shadow: 0 0 20px rgba(241, 196, 15, 0.4); transform: scale(1); }
            to { text-shadow: 0 0 40px rgba(241, 196, 15, 0.8); transform: scale(1.05); }
        }

        /* ç´™å¹é›ªã®ã‚¹ã‚¿ã‚¤ãƒ« */
        #confetti-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 0;
        }
        .confetti {
            position: absolute;
            width: 10px; height: 10px;
            background-color: #f00;
            opacity: 0.8;
        }

    </style>
</head>
<body>

<div id="game-container">
    <div id="top-bar">
        <div id="dice-container">
            <div class="dice face-1" id="dice-0"><div class="pip"></div></div>
        </div>

        <div class="status-group">
            <div class="status-header-row">
                <div class="status-label">LEVEL <span id="level-display" style="color:var(--text-color); font-size:1.2em">1</span></div>
                <div class="status-value" id="xp-text">0 / 50</div>
            </div>
            <div class="bar-bg"><div id="level-bar-fill"></div></div>
        </div>

        <div class="status-group">
            <div class="status-header-row">
                <div class="status-value" id="wave-timer-text" style="color: #ccc;">20.00sec.</div>
                <div class="status-label" style="text-align: right;">WAVE <span id="wave-display" style="color:var(--text-color); font-size:1.2em">1</span></div>
            </div>
            <div class="bar-bg"><div id="wave-bar-fill"></div></div>
        </div>
    </div>

    <div id="left-sidebar">
        <div id="skill-list-container">
            </div>
        <div id="hp-container">
            <div class="hp-header">
                <span>PLAYER HP</span>
                <span id="hp-text">100/100</span>
            </div>
            <div class="hp-bar-bg"><div id="hp-bar-fill"></div></div>
        </div>
    </div>

    <div id="game-viewport-wrapper">
        <canvas id="gameCanvas"></canvas>
        
        <div id="title-screen" class="overlay">
            <div class="game-title">DICE SURVIVORS</div>
            <div class="menu-buttons">
                <button id="btn-start" class="menu-btn" onclick="startGame()">GAME START</button>
                <button id="btn-shop" class="menu-btn" onclick="openShop()">SHOP</button>
            </div>
            
            <div class="credit-display">CREDITS: <span id="title-credits">0</span></div>

            <div class="volume-control">
                <span>SE VOLUME</span>
                <input type="range" id="title-volume" min="0" max="100" value="50">
                <span id="title-vol-text">50%</span>
            </div>
            <div class="volume-control">
                <span>BGM VOLUME</span>
                <input type="range" id="title-bgm-volume" min="0" max="100" value="40">
                <span id="title-bgm-text">40%</span>
            </div>

            <div style="margin-top: 30px; font-size: 14px; color: #888; letter-spacing: 1px;">
                éŸ³æ¥½ï¼šé­”ç‹é­‚
            </div>
        </div>

        <div id="shop-screen" class="overlay">
            <div class="shop-header">
                <div class="shop-title">SHOP</div>
                <div class="shop-credits">CREDITS: <span id="shop-credits-display">0</span></div>
            </div>
            <div class="shop-grid" id="shop-container">
                </div>
            <div class="shop-grid" id="shop-container"></div>
            
            <button class="menu-btn" style="margin-top: 20px; background:#c0392b; border-color:#e74c3c; font-size:18px;" onclick="refundUpgrades()">
                RESET & REFUND ALL
            </button>

            <button class="back-btn" onclick="closeShop()">BACK TO TITLE</button>
        </div>

        <div id="pause-screen" class="overlay">
            <h1>PAUSED</h1>
            <p>Press Esc to Resume</p>
            <div class="volume-control" style="margin-bottom: 20px;">
                <span>SE VOLUME</span>
                <input type="range" id="pause-volume" min="0" max="100" value="50">
                <span id="pause-vol-text">50%</span>
            </div>
            <div class="volume-control" style="margin-bottom: 20px;">
                <span>BGM VOLUME</span>
                <input type="range" id="pause-bgm-volume" min="0" max="100" value="40">
                <span id="pause-bgm-text">40%</span>
            </div>
            <button class="restart-btn" onclick="backToTitle()">TITLE</button>
        </div>

        <div id="game-over-screen" class="overlay">
            <h1>GAME OVER</h1>
            <div style="margin-bottom: 20px; text-align: center;">
                <div style="font-size: 30px; color: #fff; font-weight: bold;">
                    SCORE: <span id="go-score">0</span>
                </div>
                <div style="font-size: 18px; color: #aaa;">
                    HIGH SCORE: <span id="go-high-score">0</span>
                </div>
                <div style="font-size: 14px; color: #f1c40f; margin-top: 5px;">
                    +<span id="go-credits">0</span> CREDITS
                </div>
            </div>
            <button class="restart-btn" onclick="backToTitle()">TITLE</button>
        </div>

        <div id="ending-screen" class="overlay" style="display:none;">
            <div id="confetti-container"></div>

            <h1 class="ending-title">CONGRATULATIONS!</h1>
            <div style="font-size: 20px; color: #f1c40f; margin-bottom: 30px; text-shadow: 0 0 10px rgba(241, 196, 15, 0.5);">
                YOU SURVIVED THE HELL
            </div>

            <div style="margin-bottom: 30px; text-align: center; z-index: 10;">
                <div style="font-size: 30px; color: #fff; font-weight: bold;">
                    FINAL SCORE: <span id="ed-score">0</span>
                </div>
                <div style="font-size: 18px; color: #aaa;">
                    HIGH SCORE: <span id="ed-high-score">0</span>
                </div>
                <div style="font-size: 18px; color: #f1c40f; margin-top: 10px;">
                    +<span id="ed-credits">0</span> CREDITS
                </div>
            </div>
            
            <button class="restart-btn" style="z-index: 10; background: rgba(0,0,0,0.5);" onclick="backToTitle()">RETURN TO TITLE</button>
        </div>

        <div id="level-up-screen" class="overlay" style="display:none;">
            <div class="level-up-container">
                <div class="level-up-title">LEVEL UP!</div>
                
                <div id="weapon-select-container">
                    <div class="level-up-instruction">æ–°ã—ã„æ­¦å™¨ã‚’é¸ã‚“ã§ãã ã•ã„</div>
                    <div class="card-container" id="choice-cards-area"></div>
                </div>

                <div id="slot-select-container">
                    <div class="level-up-instruction">æ›¸ãæ›ãˆã‚‹å‡ºç›®ã‚’é¸ã‚“ã§ãã ã•ã„</div>
                    <div class="level-up-instruction" style="font-size:14px; color:#aaa;">(åŒã˜æ­¦å™¨ãªã‚‰Lv+2 / é•ã†æ­¦å™¨ãªã‚‰Lv+1)</div>
                    <div class="slot-grid" id="slot-buttons-area"></div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    // --- å®šæ•°ãƒ»è¨­å®š ---
    const GAME_WIDTH = 987;
    const GAME_HEIGHT = 577;
    const DICE_ROLL_INTERVAL = 3000;
    const WAVE_INTERVAL = 15000; // â˜…å¤‰æ›´: 20000 -> 15000 (15ç§’)
    const PLAYER_SPEED = 4;

    // æ­¦å™¨å®šç¾©
    const WEAPON_TYPES = {
        missile: {
            id: 'missile',
            name: 'ãƒŸã‚µã‚¤ãƒ«',
            color: '#e74c3c',
            desc: 'æœ€ã‚‚è¿‘ã„æ•µã‚’è¿½å°¾ã—çˆ†ç™ºã™ã‚‹å¼¾ã‚’ç™ºå°„',
            effectDesc: 'å¼¾æ•°ãŒå¢—åŠ '
        },
        machinegun: {
            id: 'machinegun',
            name: 'ãƒã‚·ãƒ³ã‚¬ãƒ³',
            color: '#f1c40f',
            desc: 'æœ€ã‚‚è¿‘ã„æ•µã¸é«˜é€Ÿã§ç›´é€²ã™ã‚‹å¼¾ã‚’é€£å°„',
            effectDesc: 'å¼¾æ•°ãŒå¤§ããå¢—åŠ '
        },
        shockwave: {
            id: 'shockwave',
            name: 'ã‚·ãƒ§ãƒƒã‚¯ã‚¦ã‚§ãƒ¼ãƒ–',
            color: '#3498db',
            desc: 'è‡ªæ©Ÿã‚’ä¸­å¿ƒã«æ•µã‚’å¼¾ãé£›ã°ã—ã€æ•µã®å¼¾ä¸¸ã‚’æ¶ˆæ»…ã•ã›ã‚‹è¡æ’ƒæ³¢ã‚’ç™ºç”Ÿ',
            effectDesc: 'ç¯„å›²ãŒæ‹¡å¤§'
        },
        drone: {
            id: 'drone',
            name: 'ãƒ‰ãƒ­ãƒ¼ãƒ³',
            color: '#2ecc71',
            desc: 'è‡ªæ©Ÿã®å‘¨å›²ã‚’å›è»¢ã—ãªãŒã‚‰åºƒãŒã‚‹å¼¾ã‚’ç™ºå°„',
            effectDesc: 'å¼¾æ•°ãŒå¢—åŠ '
        },
        gravity: {
            id: 'gravity',
            name: 'ã‚°ãƒ©ãƒ“ãƒ†ã‚£ã‚¨ãƒªã‚¢',
            color: '#9b59b6',
            desc: 'ãƒ©ãƒ³ãƒ€ãƒ ãªä½ç½®ã«éˆè¶³åŒ–ã¨ç¶™ç¶šãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹ã‚¨ãƒªã‚¢ã‚’è¨­ç½®',
            effectDesc: 'ç¯„å›²ã¨æŒç¶šæ™‚é–“ãŒå¢—åŠ '
        }
    };

    // --- ã‚·ãƒ§ãƒƒãƒ—ãƒ»ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰è¨­å®š ---
    // --- ã‚·ãƒ§ãƒƒãƒ—ãƒ»ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰è¨­å®š ---
    const UPGRADE_CONFIG = {
        atk: { id: 'atk', name: 'æ”»æ’ƒåŠ›å¼·åŒ–', desc: 'å…¨æ­¦å™¨ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ãŒ10%å¢—åŠ ã—ã¾ã™', maxLevel: 5, costs: [4000, 8000, 16000, 32000, 64000] },
        hp: { id: 'hp', name: 'æœ€å¤§HPå¼·åŒ–', desc: 'æœ€å¤§HPãŒ+20å¢—åŠ ã—ã¾ã™', maxLevel: 5, costs: [1000, 2000, 4000, 8000, 16000] },
        regen: { id: 'regen', name: 'HPè‡ªå‹•å›å¾©', desc: 'HPãŒæ¯ç§’ 2 ãšã¤å›å¾©ã—ã¾ã™', maxLevel: 5, costs: [4000, 8000, 16000, 32000, 64000] },
        dice: { id: 'dice', name: 'åˆæœŸãƒ€ã‚¤ã‚¹å¢—åŠ ', desc: 'ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã®ãƒ€ã‚¤ã‚¹ãŒ1ã¤å¢—ãˆã¾ã™', maxLevel: 1, costs: [100000] },
        speed: { id: 'speed', name: 'ãƒ€ã‚¤ã‚¹åŠ é€Ÿ', desc: 'ãƒ€ã‚¤ã‚¹ãƒ­ãƒ¼ãƒ«é–“éš”ãŒ10%çŸ­ç¸®ã•ã‚Œã¾ã™', maxLevel: 5, costs: [4000, 8000, 16000, 32000, 64000] },
        luck: { id: 'luck', name: 'ã‚¸ã‚§ãƒ å¢—é‡', desc: 'ã‚¸ã‚§ãƒ ã®ãƒ‰ãƒ­ãƒƒãƒ—é‡(çµŒé¨“å€¤ãƒ»ã‚¹ã‚³ã‚¢)ãŒ20%å¢—åŠ ã—ã¾ã™', maxLevel: 5, costs: [2000, 4000, 8000, 16000, 32000] },
        time: { id: 'time', name: 'WAVEçŸ­ç¸®', desc: 'æ¬¡ã®WAVEã¾ã§ã®æ™‚é–“ãŒ1ç§’çŸ­ç¸®ã•ã‚Œã¾ã™', maxLevel: 5, costs: [1000, 2000, 4000, 8000, 16000] },
        curse: { id: 'curse', name: 'æ•µæ•°å¢—åŠ ', desc: 'æ•µã®å‡ºç¾æ•°ãŒ10%å¢—åŠ ã—ã¾ã™(ç¨¼ãåŠ¹ç‡UP)', maxLevel: 5, costs: [1000, 2000, 4000, 8000, 16000] },
        
        // --- æ–°è¦è¿½åŠ åˆ† ---
        pickup: { id: 'pickup', name: 'å›åç¯„å›²æ‹¡å¤§', desc: 'ã‚¢ã‚¤ãƒ†ãƒ ã®å›åç¯„å›²ãŒ15%åºƒãŒã‚Šã¾ã™', maxLevel: 5, costs: [4000, 8000, 16000, 32000, 64000] },
        missile_ex: { id: 'missile_ex', name: 'ãƒŸã‚µã‚¤ãƒ«å¼·åŒ–', desc: 'ãƒŸã‚µã‚¤ãƒ«ã®çˆ†ç™ºç¯„å›²ãŒ15%åºƒãŒã‚Šã¾ã™', maxLevel: 5, costs: [4000, 8000, 16000, 32000, 64000] },
        mg_pierce: { id: 'mg_pierce', name: 'ãƒã‚·ãƒ³ã‚¬ãƒ³å¼·åŒ–', desc: 'ãƒã‚·ãƒ³ã‚¬ãƒ³ã®è²«é€šæ•°ãŒ+1ã•ã‚Œã¾ã™', maxLevel: 5, costs: [4000, 8000, 16000, 32000, 64000] },
        shock_up: { id: 'shock_up', name: 'è¡æ’ƒæ³¢å¼·åŒ–', desc: 'ã‚·ãƒ§ãƒƒã‚¯ã‚¦ã‚§ãƒ¼ãƒ–ã®ç™ºå‹•å›æ•°ãŒ+1ã•ã‚Œã¾ã™', maxLevel: 5, costs: [4000, 8000, 16000, 32000, 64000] },
        drone_up: { id: 'drone_up', name: 'ãƒ‰ãƒ­ãƒ¼ãƒ³å¼·åŒ–', desc: 'ãƒ‰ãƒ­ãƒ¼ãƒ³ã®æŒç¶šæ™‚é–“ãŒ10%å»¶é•·ã•ã‚Œã¾ã™', maxLevel: 5, costs: [4000, 8000, 16000, 32000, 64000] },
        grav_up: { id: 'grav_up', name: 'é‡åŠ›ã‚¨ãƒªã‚¢å¼·åŒ–', desc: 'ã‚°ãƒ©ãƒ“ãƒ†ã‚£ã‚¨ãƒªã‚¢ã®æ¸›é€ŸåŠ¹æœãŒå¼·åŒ–ã•ã‚Œã¾ã™', maxLevel: 5, costs: [4000, 8000, 16000, 32000, 64000] }
    };

    // ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã®ä¿å­˜ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
    let upgradeLevels = JSON.parse(localStorage.getItem('diceSurvivors_upgrades')) || {};
    
    // å…¨ã‚­ãƒ¼ã‚’æ•°å€¤å‹ã§åˆæœŸåŒ–
    Object.keys(UPGRADE_CONFIG).forEach(key => {
        upgradeLevels[key] = Number(upgradeLevels[key]) || 0;
    });
    
    // å¼·åˆ¶çš„ã«æ•°å€¤å‹ã«å¤‰æ›ã—ã¦ãŠã (NaNé˜²æ­¢)
    upgradeLevels.atk = Number(upgradeLevels.atk) || 0;
    upgradeLevels.hp = Number(upgradeLevels.hp) || 0;
    upgradeLevels.regen = Number(upgradeLevels.regen) || 0;
    upgradeLevels.dice = Number(upgradeLevels.dice) || 0;
    upgradeLevels.speed = Number(upgradeLevels.speed) || 0;
    upgradeLevels.luck = Number(upgradeLevels.luck) || 0;
    upgradeLevels.time = Number(upgradeLevels.time) || 0;
    upgradeLevels.curse = Number(upgradeLevels.curse) || 0;

    // åˆæœŸãƒ€ã‚¤ã‚¹ã‚¹ãƒ­ãƒƒãƒˆçŠ¶æ…‹ (å‡ºç›®1~6)
    // æœ€åˆã¯ã™ã¹ã¦ãƒŸã‚µã‚¤ãƒ«

    let diceSlots = [
        { type: 'missile', level: 1 }, // Face 1
        { type: 'missile', level: 2 }, // Face 2
        { type: 'missile', level: 3 }, // Face 3
        { type: 'missile', level: 4 }, // Face 4
        { type: 'missile', level: 5 }, // Face 5
        { type: 'missile', level: 6 }  // Face 6
    ];
    
    // --- ã‚²ãƒ¼ãƒ ã‚¹ãƒ†ãƒ¼ãƒˆ ---
    const canvas = document.getElementById('gameCanvas');
    canvas.width = GAME_WIDTH;
    canvas.height = GAME_HEIGHT;
    const ctx = canvas.getContext('2d');
    let animationFrameId; // è¿½åŠ : ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åœæ­¢ç”¨
    let isGameRunning = false; // è¿½åŠ : ã‚²ãƒ¼ãƒ å®Ÿè¡Œä¸­ãƒ•ãƒ©ã‚°

    let isPaused = false;
    let isGameOver = false;
    let isLevelUp = false;
    let lastTime = 0;
    
    // â˜…è¿½åŠ : ã‚¹ã‚³ã‚¢ã¨ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ç®¡ç†
    let score = 0; // ä»Šå›ã®ã‚¹ã‚³ã‚¢ (ç·ç²å¾—çµŒé¨“å€¤)
    // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰èª­ã¿è¾¼ã¿ (ãªã‘ã‚Œã°0)
    let highScore = parseInt(localStorage.getItem('diceSurvivors_highScore')) || 0;
    let totalCredits = parseInt(localStorage.getItem('diceSurvivors_credits')) || 0;

    const keys = { w:false, a:false, s:false, d:false };
    // ... (ä»¥ä¸‹æ—¢å­˜ã‚³ãƒ¼ãƒ‰)

    const player = { 
        x: GAME_WIDTH/2, y: GAME_HEIGHT/2, 
        size: 8, color: '#00ffff',
        hp: 100, maxHp: 100
    };

    let enemies = [];
    let projectiles = []; 
    let particles = [];
    let jewels = [];
    let diceDrops = []; // â˜…è¿½åŠ : ãƒ€ã‚¤ã‚¹ãƒ‰ãƒ­ãƒƒãƒ—ã‚¢ã‚¤ãƒ†ãƒ ç®¡ç†ç”¨
    let areaEffects = [];

    // â˜…è¿½åŠ : Wave50ãƒœã‚¹æ’ƒç ´ãƒ•ãƒ©ã‚°
    let hasDefeatedWave50Boss = false;

    // å¤‰æ•°å®šç¾©ã‚¨ãƒªã‚¢ã«è¿½åŠ 
    let enemyProjectiles = []; // æ•µã®å¼¾ä¸¸ç®¡ç†ç”¨

    // ã‚¯ãƒ©ã‚¹å®šç¾©ã‚¨ãƒªã‚¢ã«è¿½åŠ ï¼ˆEnemyã‚¯ãƒ©ã‚¹ã®å‰ã‚ãŸã‚Šï¼‰
    class EnemyProjectile {
        constructor(x, y, vx, vy) {
            this.x = x;
            this.y = y;
            this.vx = vx;
            this.vy = vy;
            this.size = 6;
            this.color = '#ff00ff';
            this.life = 600; // å¯¿å‘½
        }

        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.life--;
        }

        draw() {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    let level = 1;
    let currentXp = 0;
    let nextLevelXp = 50;
    let wave = 1;
    
    let diceTimer = 0;
    let waveTimer = 0;
    let selectedNewWeaponId = null; // Level Up Temporary State

    

    // DOM Elements
    const domLevel = document.getElementById('level-display');
    const domLevelBar = document.getElementById('level-bar-fill');
    const domXpText = document.getElementById('xp-text');
    const domWave = document.getElementById('wave-display');
    const domWaveBar = document.getElementById('wave-bar-fill');
    const domWaveTimerText = document.getElementById('wave-timer-text');
    let domDiceDivs = Array.from(document.querySelectorAll('#dice-container .dice')); // letã«å¤‰æ›´    
    const domHpText = document.getElementById('hp-text');
    const domHpBar = document.getElementById('hp-bar-fill');
    const domSkillList = document.getElementById('skill-list-container');
    
    // Screens
    const screenPause = document.getElementById('pause-screen');
    const screenGameOver = document.getElementById('game-over-screen');
    const screenLevelUp = document.getElementById('level-up-screen');
    const containerWeaponSelect = document.getElementById('weapon-select-container');
    const containerSlotSelect = document.getElementById('slot-select-container');
    const areaChoiceCards = document.getElementById('choice-cards-area');
    const areaSlotButtons = document.getElementById('slot-buttons-area');

    // --- åˆæœŸåŒ– ---
    function initUI() {
        updateSkillList();
        updateHpUI();
        updateXpUI();
    }


    // --- ã‚µã‚¦ãƒ³ãƒ‰ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ  ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let audioCtx = new AudioContext();
    
    const soundBuffers = {};
    let masterVolume = 0.5; // SEéŸ³é‡
    let bgmVolume = 0.4;    // â˜…è¿½åŠ : BGMéŸ³é‡
    let currentBgmSource = null; // â˜…è¿½åŠ : ç¾åœ¨å†ç”Ÿä¸­ã®BGMã‚½ãƒ¼ã‚¹
    let currentBgmGainNode = null; // â˜…è¿½åŠ : éŸ³é‡å¤‰æ›´ç”¨ã«ä¿æŒ

    // èª­ã¿è¾¼ã¿ãŸã„ãƒ•ã‚¡ã‚¤ãƒ«ãƒªã‚¹ãƒˆ
    const SOUND_FILES = {
        missile: 'sounds/shoot_missile.mp3',
        machinegun: 'sounds/shoot_mg.mp3',
        shockwave: 'sounds/shoot_shock.mp3',
        drone: 'sounds/shoot_drone.mp3',
        gem: 'sounds/gem.mp3',
        levelup: 'sounds/levelup.mp3',
        gameover: 'sounds/gameover.mp3',
        click: 'sounds/click.mp3',
        gravity: 'sounds/gravity.mp3',
        explosion: 'sounds/explosion.mp3',
        hit: 'sounds/hit.mp3',

        // â˜…è¿½åŠ : BGMãƒ•ã‚¡ã‚¤ãƒ«
        bgm_title: 'sounds/bgm_title.mp3',
        bgm_game: 'sounds/bgm_game.mp3',
        bgm_gameover: 'sounds/bgm_gameover.mp3',
        bgm_ending: 'sounds/bgm_ending.mp3'
    };

    // (loadSounds é–¢æ•°ã¯å¤‰æ›´ãªã—)
    async function loadSounds() {
        for (const [key, url] of Object.entries(SOUND_FILES)) {
            try {
                const response = await fetch(url);
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                soundBuffers[key] = audioBuffer;
            } catch (e) {
                console.warn(`Sound load failed: ${url}`, e);
            }
        }
    }

    // (playSound é–¢æ•°ã¯å¤‰æ›´ãªã—)
    function playSound(key, pitchVar = 0) {
        if (masterVolume <= 0 || !soundBuffers[key]) return;
        if (audioCtx.state === 'suspended') audioCtx.resume();

        const source = audioCtx.createBufferSource();
        source.buffer = soundBuffers[key];
        if (pitchVar > 0) source.playbackRate.value = 1.0 + (Math.random() - 0.5) * pitchVar;

        const gainNode = audioCtx.createGain();
        gainNode.gain.value = masterVolume;

        source.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        source.start(0);
    }

    // â˜…è¿½åŠ : BGMå†ç”Ÿé–¢æ•°
    function playBgm(key) {
        if (!soundBuffers[key]) return;
        
        stopBgm();

        // ã“ã“ã«ã‚ã£ãŸ "if (audioCtx.state === 'suspended') audioCtx.resume();" ã‚’å‰Šé™¤

        const source = audioCtx.createBufferSource();
        source.buffer = soundBuffers[key];
        source.loop = true;

        const gainNode = audioCtx.createGain();
        gainNode.gain.value = bgmVolume;

        source.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        source.start(0);

        currentBgmSource = source;
        currentBgmGainNode = gainNode;
    }

    // â˜…è¿½åŠ : BGMåœæ­¢é–¢æ•°
    function stopBgm() {
        if (currentBgmSource) {
            try {
                currentBgmSource.stop();
            } catch(e) {}
            currentBgmSource = null;
            currentBgmGainNode = null;
        }
    }

    // (setGlobalVolume ã¯ SEç”¨ã¨ã—ã¦æ®‹ã™)
    function setGlobalVolume(val) {
        masterVolume = val / 100;
        document.getElementById('title-volume').value = val;
        document.getElementById('pause-volume').value = val;
        document.getElementById('title-vol-text').innerText = val + '%';
        document.getElementById('pause-vol-text').innerText = val + '%';
        localStorage.setItem('diceSurvivors_volume', val);
    }

    // â˜…è¿½åŠ : BGMéŸ³é‡å¤‰æ›´é–¢æ•°
    function setBgmVolume(val) {
        bgmVolume = val / 100;
        // UIæ›´æ–°
        document.getElementById('title-bgm-volume').value = val;
        document.getElementById('pause-bgm-volume').value = val;
        document.getElementById('title-bgm-text').innerText = val + '%';
        document.getElementById('pause-bgm-text').innerText = val + '%';
        
        // å†ç”Ÿä¸­ã®BGMãŒã‚ã‚Œã°å³åº§ã«éŸ³é‡åæ˜ 
        if(currentBgmGainNode) {
            currentBgmGainNode.gain.value = bgmVolume;
        }
        localStorage.setItem('diceSurvivors_bgm_volume', val);
    }

    

    function setDiceFace(element, faceNum) {
        element.className = `dice face-${faceNum}`;
        if(element.classList.contains('rolling')) element.classList.add('rolling');
        element.innerHTML = '';
        const pipCount = Math.max(1, Math.min(6, faceNum));
        for(let i=0; i<pipCount; i++) {
            const pip = document.createElement('div');
            pip.className = 'pip';
            element.appendChild(pip);
        }
    }

    // --- å…¥åŠ›ç³» ---
    window.addEventListener('keydown', e => {
        if(e.key === 'Escape' && !isGameOver && !isLevelUp) togglePause();
        if(!isPaused && !isGameOver && !isLevelUp) {
            if(e.key === 'w' || e.key === 'W') keys.w = true;
            if(e.key === 'a' || e.key === 'A') keys.a = true;
            if(e.key === 's' || e.key === 'S') keys.s = true;
            if(e.key === 'd' || e.key === 'D') keys.d = true;
        }
    });
    window.addEventListener('keyup', e => {
        if(e.key === 'w' || e.key === 'W') keys.w = false;
        if(e.key === 'a' || e.key === 'A') keys.a = false;
        if(e.key === 's' || e.key === 'S') keys.s = false;
        if(e.key === 'd' || e.key === 'D') keys.d = false;
    });

    function togglePause() {
        isPaused = !isPaused;
        screenPause.style.display = isPaused ? 'flex' : 'none';
        if(!isPaused) {
            lastTime = performance.now();
            // ã“ã“ã«ã‚ã£ãŸ requestAnimationFrame(gameLoop); ã‚’å‰Šé™¤
        }
    }

    // --- ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ã‚·ã‚¹ãƒ†ãƒ  ---

    function triggerLevelUp() {
        playSound('levelup');
        isLevelUp = true;
        screenLevelUp.style.display = 'flex';
        
        // Step 1 UIè¡¨ç¤º
        containerWeaponSelect.style.display = 'block';
        containerSlotSelect.style.display = 'none';

        // 3ã¤ã®é¸æŠè‚¢ã‚’ç”Ÿæˆ (é‡è¤‡ãªã—)
        areaChoiceCards.innerHTML = '';
        const keys = Object.keys(WEAPON_TYPES);
        
        // â˜…å¤‰æ›´: Fisher-Yates shuffle ã§ãƒ©ãƒ³ãƒ€ãƒ ã«ä¸¦ã³æ›¿ãˆ
        for (let i = keys.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [keys[i], keys[j]] = [keys[j], keys[i]];
        }

        // å…ˆé ­3ã¤ã‚’å–å¾—
        const selectedKeys = keys.slice(0, 3);
        const choices = selectedKeys.map(k => WEAPON_TYPES[k]);

        choices.forEach(weapon => {
            const card = document.createElement('div');
            card.className = 'choice-card';
            card.style.borderColor = weapon.color;
            card.innerHTML = `
                <div class="choice-name" style="color:${weapon.color}">${weapon.name}</div>
                <div class="choice-desc">${weapon.desc}</div>
                <div class="choice-bonus">${weapon.effectDesc}</div>
            `;
            card.onclick = () => selectLevelUpWeapon(weapon.id);
            areaChoiceCards.appendChild(card);
        });
    }

    function selectLevelUpWeapon(weaponId) {
        selectedNewWeaponId = weaponId;
        
        // Step 2 UIã¸é·ç§»
        containerWeaponSelect.style.display = 'none';
        containerSlotSelect.style.display = 'flex';

        // ã‚¹ãƒ­ãƒƒãƒˆé¸æŠãƒœã‚¿ãƒ³ç”Ÿæˆ
        areaSlotButtons.innerHTML = '';
        diceSlots.forEach((slot, index) => {
            const faceNum = index + 1;
            const isSame = slot.type === selectedNewWeaponId;
            const nextLevel = isSame ? slot.level + 2 : slot.level + 1; // ä»•æ§˜ï¼šåŒã˜ãªã‚‰+2, é•ã†ãªã‚‰+1 (ã“ã“ã§ã¯Lv1ã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆã§ã¯ãªãã€ä»Šã®ãƒ¬ãƒ™ãƒ«ã‚’å¼•ãç¶™ãæŒ™å‹•ã¨ã™ã‚‹ã€‚å•é¡Œæ–‡ã®ã€Œå…¥ã‚Œæ›¿ãˆãŸå‡ºç›®ã®ãƒ¬ãƒ™ãƒ«ãŒ1ä¸ŠãŒã‚‹ã€ã‚’ã€Œç¾åœ¨ã®ãã®ã‚¹ãƒ­ãƒƒãƒˆã®ãƒ¬ãƒ™ãƒ«+1ã€ã¨è§£é‡ˆ)
            // â€»ã‚‚ã—ã€Œé•ã†æ­¦å™¨ã«å…¥ã‚Œæ›¿ãˆãŸã‚‰Lv1ã«ãªã‚‹ã€ã¨ã„ã†è§£é‡ˆãªã‚‰å¤‰æ›´ãŒå¿…è¦ã§ã™ãŒã€ã€Œå…¥ã‚Œæ›¿ãˆãŸå‡ºç›®ã®ãƒ¬ãƒ™ãƒ«ãŒï¼‘ä¸ŠãŒã‚‹ã€ã¨ã‚ã‚‹ã®ã§ã€æ—¢å­˜Lv+1ã¨ã—ã¾ã™ã€‚

            const btn = document.createElement('div');
            btn.className = 'slot-btn';
            btn.style.borderColor = isSame ? WEAPON_TYPES[slot.type].color : '#999';
            
            // ãƒ€ã‚¤ã‚¹ã‚¢ã‚¤ã‚³ãƒ³ç”Ÿæˆ
            const diceDiv = document.createElement('div');
            setDiceFace(diceDiv, faceNum);
            
            btn.appendChild(diceDiv);
            btn.innerHTML += `
                <div class="slot-info">
                    <div style="font-weight:bold;">å‡ºç›® ${faceNum}</div>
                    <div style="font-size:12px; color:#555;">ç¾åœ¨: ${WEAPON_TYPES[slot.type].name} Lv.${slot.level}</div>
                </div>
                <div class="slot-preview" style="color:${isSame ? '#2ecc71' : '#e74c3c'}">
                    Lv.${nextLevel}
                </div>
            `;
            btn.onclick = () => applyLevelUp(index, nextLevel);
            areaSlotButtons.appendChild(btn);
        });
    }

    function applyLevelUp(slotIndex, nextLevel) {
        // ãƒ‡ãƒ¼ã‚¿æ›´æ–°
        diceSlots[slotIndex] = {
            type: selectedNewWeaponId,
            level: nextLevel
        };
        updateSkillList();

        // å¾©å¸°å‡¦ç†
        isLevelUp = false;
        screenLevelUp.style.display = 'none';
        // ã“ã“ã«ã‚ã£ãŸãƒ«ãƒ¼ãƒ—å†é–‹å‡¦ç†ã‚’å‰Šé™¤
    }

    // --- ã‚²ãƒ¼ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ ---

    class Enemy {
        constructor(x, y, type = 'normal', isBoss = false, noGem = false) {
            this.x = x;
            this.y = y;
            this.type = type;
            this.isBoss = isBoss;
            this.noGem = noGem;
            
            this.timer = 0; 
            
            // --- å°„æ’ƒå‹ç”¨: ãƒãƒ¼ã‚¹ãƒˆç®¡ç† ---
            this.burstTimer = 0;
            this.isBursting = false;
            this.burstCount = 0;
            
            // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¨­å®š
            let hpMult = 1;
            let speedMult = 1;
            let sizeBase = 12;
            let color = '#ff4444';

            if (this.type === 'fortress') {
                hpMult = 3.0; speedMult = 0.6; sizeBase = 20; color = '#8d6e63';
            } else if (this.type === 'rusher') {
                hpMult = 0.4; speedMult = 0.8; sizeBase = 10; color = '#e67e22';
                this.rushAngle = Math.random() * Math.PI * 2;
            } else if (this.type === 'shooter') {
                hpMult = 0.9; speedMult = 1.4; sizeBase = 14; color = '#2980b9';
            } else if (this.type === 'summoner') {
                hpMult = 2.0; speedMult = 0.5; sizeBase = 18; color = '#16a085';
            } else if (this.type === 'teleporter') {
                hpMult = 2.0; speedMult = 0.6; sizeBase = 16; color = '#8e44ad';
                this.state = 0; 
            }

            // â˜…å¤‰æ›´: Wave55ä»¥é™ã®HPã‚¤ãƒ³ãƒ•ãƒ¬è¨ˆç®—
            // åŸºæœ¬HPè¨ˆç®—
            let baseHp = 10 + (wave * 2);
            
            // Wave55ã‚’è¶…ãˆã¦ã„ãŸã‚‰ã€1Waveã”ã¨ã«HPå€ç‡ã‚’ä¸Šã’ã‚‹
            if (wave > 55) {
                // ä¾‹: Wave65ãªã‚‰ (65-55)*0.1 = 1.0 -> åŸºæœ¬HPã®2å€
                // ä¾‹: Wave75ãªã‚‰ (75-55)*0.1 = 2.0 -> åŸºæœ¬HPã®3å€
                const inflationMult = 1 + (wave - 55) * 0.1;
                baseHp *= inflationMult;
            }

            if (this.isBoss) {
                this.size = sizeBase * 3;
                this.hp = (300 + (wave * 60)) * hpMult;
                
                // ãƒœã‚¹ã‚‚åŒæ§˜ã«ã‚¤ãƒ³ãƒ•ãƒ¬ã•ã›ã‚‹
                if (wave > 55) {
                    const inflationMult = 1 + (wave - 55) * 0.1;
                    this.hp *= inflationMult;
                }
                
                this.speed = 0.5 * speedMult;
                this.color = color;
            } else {
                this.size = sizeBase;
                this.hp = baseHp * hpMult;
                this.speed = (1.0 + (Math.random() * 0.25)) * speedMult;
                this.color = color;
            }
            
            this.maxHp = this.hp; 
            this.baseSpeed = this.speed;
            this.slowTimer = 0;
            this.dps = this.isBoss ? 50 : (25 + (wave * 2));
        }

        update(dt) {
            // â˜…å¤‰æ›´: æ¸›é€Ÿå€ç‡(speedFactor)ã®è¨ˆç®—å¼ã‚’ä¿®æ­£
            let speedFactor = 1.0;
            
            if(this.slowTimer > 0) {
                // ã‚°ãƒ©ãƒ“ãƒ†ã‚£å¼·åŒ–Lvã‚’å–å¾—
                const gravLv = upgradeLevels.grav_up || 0;
                
                // å¤‰æ›´å‰: 0.6 - (gravLv * 0.1)  (Lv0=60%, Lv5=10%)
                
                // â˜…å¤‰æ›´å¾Œ: 
                // Lv0ã§ 0.8 (80%é€Ÿåº¦ = 20%æ¸›é€Ÿ)
                // 1ãƒ¬ãƒ™ãƒ«ã”ã¨ã« -0.05
                // Lv5ã§ 0.55 (55%é€Ÿåº¦ = 45%æ¸›é€Ÿ)
                speedFactor = 0.8 - (gravLv * 0.05);

                // å¿µã®ãŸã‚ä¸‹é™ã‚­ãƒ£ãƒƒãƒ—ï¼ˆå®Œå…¨ã«æ­¢ã¾ã‚‰ãªã„ã‚ˆã†ã«0.1ä»¥ä¸Šã«ã™ã‚‹ãªã©ï¼‰
                speedFactor = Math.max(0.1, speedFactor);
                
                this.slowTimer -= dt;
            }

            // ç¾åœ¨ã®ç§»å‹•é€Ÿåº¦ã«å€ç‡ã‚’é©ç”¨
            let currentSpeed = this.speed * speedFactor;

            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const dist = Math.hypot(dx, dy);
            
            this.timer++;

            // --- è¡Œå‹•ãƒ­ã‚¸ãƒƒã‚¯ ---
            if (this.type === 'teleporter') {
                if (this.state === 0) {
                    if (dist > 0) {
                        this.x += (dx / dist) * currentSpeed;
                        this.y += (dy / dist) * currentSpeed;
                    }
                    if (this.timer > 200) { this.state = 1; this.timer = 0; }
                } else if (this.state === 1) {
                    if (this.timer > 60) {
                        this.x = Math.random() * (GAME_WIDTH - 100) + 50;
                        this.y = Math.random() * (GAME_HEIGHT - 100) + 50;
                        this.state = 2; this.timer = 0;
                        for(let i=0; i<8; i++) {
                            const ang = (Math.PI * 2 / 8) * i;
                            const spd = 1.5;
                            enemyProjectiles.push(new EnemyProjectile(this.x, this.y, Math.cos(ang)*spd, Math.sin(ang)*spd));
                        }
                    }
                } else if (this.state === 2) {
                    if (this.timer > 30) { this.state = 0; this.timer = 0; }
                }

            } else {
                // ç§»å‹•è¨ˆç®—
                let moveX = 0, moveY = 0;

                if (this.type === 'rusher') {
                    const angle = Math.atan2(dy, dx);
                    
                    // â˜…ä¿®æ­£: è›‡è¡Œã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é€²è¡Œã‚‚ã‚¹ãƒ­ãƒ¼ã«ã™ã‚‹
                    this.rushAngle += 0.04 * speedFactor; 
                    
                    // â˜…ä¿®æ­£: æ¨ªæŒ¯ã‚Œã®å¼·ã•ã«ã‚‚ã‚¹ãƒ­ãƒ¼å€ç‡ã‚’é©ç”¨ã™ã‚‹
                    const curveStrength = 4.5 * speedFactor;
                    
                    moveX = Math.cos(angle) * currentSpeed + Math.cos(this.rushAngle + angle + Math.PI/2) * curveStrength;
                    moveY = Math.sin(angle) * currentSpeed + Math.sin(this.rushAngle + angle + Math.PI/2) * curveStrength;

                } else if (this.type === 'shooter') {
                    const range = 300;
                    if (dist > range) {
                        moveX = (dx / dist) * currentSpeed;
                        moveY = (dy / dist) * currentSpeed;
                    }

                    // ãƒãƒ¼ã‚¹ãƒˆåˆ¶å¾¡
                    if (!this.isBursting) {
                        const cooldown = this.isBoss ? 200 : 400;
                        if (this.timer > cooldown && dist < 600) {
                            this.isBursting = true;
                            this.burstTimer = 0;
                            this.burstCount = 0;
                            this.timer = 0;
                        }
                    } else {
                        this.burstTimer++;
                        const fireRate = this.isBoss ? 8 : 25;
                        const shotsPerBurst = this.isBoss ? 8 : 4;

                        if (this.burstTimer >= fireRate) {
                            this.burstTimer = 0;
                            this.burstCount++;

                            const shotSpeed = 2.5;
                            const baseAngle = Math.atan2(dy, dx);

                            if (this.isBoss) {
                                const angles = [baseAngle - 0.2, baseAngle, baseAngle + 0.2];
                                angles.forEach(a => {
                                    enemyProjectiles.push(new EnemyProjectile(
                                        this.x, this.y, Math.cos(a)*shotSpeed, Math.sin(a)*shotSpeed
                                    ));
                                });
                            } else {
                                enemyProjectiles.push(new EnemyProjectile(
                                    this.x, this.y, Math.cos(baseAngle)*shotSpeed, Math.sin(baseAngle)*shotSpeed
                                ));
                            }

                            if (this.burstCount >= shotsPerBurst) {
                                this.isBursting = false;
                                this.timer = 0;
                            }
                        }
                    }

                } else if (this.type === 'summoner') {
                    moveX = (dx / dist) * currentSpeed;
                    moveY = (dy / dist) * currentSpeed;
                    
                    const summonInterval = 300;
                    if (this.timer % summonInterval === 0) {
                        const summonCount = this.isBoss ? 8 : 3;
                        for(let i=0; i<summonCount; i++) {
                            const offsetX = (Math.random() - 0.5) * 60;
                            const offsetY = (Math.random() - 0.5) * 60;
                            const minion = new Enemy(this.x + offsetX, this.y + offsetY, 'normal', false, true);
                            minion.hp = 10;
                            enemies.push(minion);
                        }
                    }
                } else {
                    moveX = (dx / dist) * currentSpeed;
                    moveY = (dy / dist) * currentSpeed;
                }

                this.x += moveX;
                this.y += moveY;
            }
        }

        draw() {
            // (å‰å›ã®æç”»ã‚³ãƒ¼ãƒ‰ã¨åŒã˜)
            if (this.type === 'teleporter' && this.state === 1) {
                if (Math.floor(this.timer / 5) % 2 === 0) return;
            }

            // â˜…å¤‰æ›´: çŠ¶æ…‹ã‚’ä¿å­˜ï¼ˆãƒ•ã‚£ãƒ«ã‚¿ã®å½±éŸ¿ã‚’ã“ã®æ•µã®æç”»ã ã‘ã«é™å®šã™ã‚‹ãŸã‚ï¼‰
            ctx.save(); 

            // â˜…å¤‰æ›´: è‰²ã‚’ç›´æ¥ç°è‰²ã«ã™ã‚‹ã®ã§ã¯ãªãã€ãƒ•ã‚£ãƒ«ã‚¿ã§å½©åº¦ã‚’è½ã¨ã™
            if (this.slowTimer > 0) {
                // å½©åº¦ã‚’20%ã¾ã§è½ã¨ã™ï¼ˆå…ƒã®è‰²ã®ãƒ‹ãƒ¥ã‚¢ãƒ³ã‚¹ã‚’æ®‹ã—ã¤ã¤ã€è‰²ãŒæŠœã‘ãŸæ„Ÿã˜ã«ãªã‚‹ï¼‰
                // å®Œå…¨ã«ãƒ¢ãƒã‚¯ãƒ­ã«ã—ãŸã„å ´åˆã¯ 'grayscale(100%)' ãªã©ã‚‚å¯
                ctx.filter = 'saturate(20%)'; 
            }

            ctx.fillStyle = this.color; // å…ƒã®è‰²ã‚’ä½¿ç”¨ã™ã‚‹
            
            ctx.beginPath();
            
            if (this.type === 'fortress') {
                ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
            } else if (this.type === 'rusher') {
                ctx.moveTo(this.x + Math.cos(this.rushAngle)*this.size, this.y + Math.sin(this.rushAngle)*this.size);
                ctx.lineTo(this.x + Math.cos(this.rushAngle + 2.6)*this.size, this.y + Math.sin(this.rushAngle + 2.6)*this.size);
                ctx.lineTo(this.x + Math.cos(this.rushAngle - 2.6)*this.size, this.y + Math.sin(this.rushAngle - 2.6)*this.size);
                ctx.fill();
            } else {
                ctx.arc(this.x, this.y, this.size/2, 0, Math.PI * 2);
                ctx.fill();
            }

            // â˜…å¤‰æ›´: æç”»ãŒçµ‚ã‚ã£ãŸã‚‰ãƒ•ã‚£ãƒ«ã‚¿è¨­å®šã‚’å…ƒã«æˆ»ã™
            ctx.restore();
            
            if (this.isBoss) {
                this.drawBossUI();
            } else {
                ctx.fillStyle = 'black';
                ctx.fillRect(this.x - 2, this.y - 2, 4, 4);
            }
        }

        drawBossUI() {
            const barWidth = 80;
            const barHeight = 8;
            const barX = this.x - barWidth / 2;
            const barY = this.y - this.size / 2 - 20;

            ctx.fillStyle = '#222';
            ctx.fillRect(barX, barY, barWidth, barHeight);
            const ratio = Math.max(0, this.hp / this.maxHp);
            ctx.fillStyle = '#e74c3c';
            ctx.fillRect(barX, barY, barWidth * ratio, barHeight);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.strokeRect(barX, barY, barWidth, barHeight);
        }
    }

    // â˜…è¿½åŠ : ãƒ€ã‚¤ã‚¹ãƒ‰ãƒ­ãƒƒãƒ—ã‚¢ã‚¤ãƒ†ãƒ 
    class DiceDrop {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.size = 20;
            this.phase = 0;
            this.magnetized = false;
        }
        update() {
            this.phase += 0.1;
            const floatY = Math.sin(this.phase) * 5; 
            
            // â˜…ä¿®æ­£: ã“ã“ã§ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è·é›¢ã‚’è¨ˆç®—ã™ã‚‹
            const dx = player.x - this.x;
            const dy = player.y - (this.y + floatY); // æµ®éŠæ¼”å‡ºã‚’è€ƒæ…®ã—ãŸä½ç½®ã¨ã®è·é›¢
            const dist = Math.hypot(dx, dy);

            // å›åç¯„å›²ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰é©ç”¨
            const pickupLv = upgradeLevels.pickup || 0;
            const magnetRange = 150 * (1 + pickupLv * 0.15);

            if(dist < magnetRange) this.magnetized = true;
            
            if(this.magnetized) {
                const speed = 8;
                this.x += (dx / dist) * speed;
                this.y += (dy / dist) * speed;
            }

            // ç”»é¢å¤–ã«å‡ºãªã„ã‚ˆã†ã«åº§æ¨™ã‚’åˆ¶é™
            const margin = this.size; 
            if(this.x < margin) this.x = margin;
            if(this.x > GAME_WIDTH - margin) this.x = GAME_WIDTH - margin;
            if(this.y < margin) this.y = margin;
            if(this.y > GAME_HEIGHT - margin) this.y = GAME_HEIGHT - margin;
        }

        draw() {
            ctx.save();
            ctx.translate(this.x, this.y + Math.sin(this.phase)*5);
            ctx.fillStyle = '#fff';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.rect(-10, -10, 20, 20);
            ctx.fill();
            ctx.stroke();
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.arc(0, 0, 4, 0, Math.PI*2);
            ctx.fill();
            ctx.restore();
        }
    }

    // æ±ç”¨ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹
    // æ±ç”¨ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹
    // æ±ç”¨ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹
    // æ±ç”¨ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚¿ã‚¤ãƒ«ã‚¯ãƒ©ã‚¹
    class Projectile {
        constructor(x, y, type, level, target) {
            this.x = x;
            this.y = y;
            this.type = type;
            this.level = level;
            this.target = target;
            this.life = 200;
            this.trail = [];
            this.angle = 0; // for Drone
            this.orbitDist = 0; // for Drone

            // Type specific init
            if(type === 'missile') {
                this.speed = 7;
                this.size = 3;
                this.color = '#e74c3c';
                const a = Math.random() * Math.PI * 2;
                this.vx = Math.cos(a) * 3; 
                this.vy = Math.sin(a) * 3;
            } else if(type === 'machinegun') {
                this.speed = 12;
                this.size = 2;
                this.color = '#f1c40f';
                // â˜…è¿½åŠ : è²«é€šç®¡ç†ç”¨ï¼ˆå½“ãŸã£ãŸæ•µã‚’è¨˜éŒ²ï¼‰
                this.hitEnemies = []; 
                
                if(target) {
                    const dx = target.x - x;
                    const dy = target.y - y;
                    const angle = Math.atan2(dy, dx);
                    const spread = (Math.random() - 0.5) * 0.2;
                    this.vx = Math.cos(angle + spread) * this.speed;
                    this.vy = Math.sin(angle + spread) * this.speed;
                } else {
                    const a = Math.random() * Math.PI * 2;
                    this.vx = Math.cos(a) * this.speed;
                    this.vy = Math.sin(a) * this.speed;
                }
            } else if(type === 'drone') {
                this.speed = 0.08; 
                this.size = 4;
                this.color = '#2ecc71';
                this.angle = Math.random() * Math.PI * 2;
                this.orbitDist = 55; 
                
                // â˜…å¤‰æ›´: æŒç¶šæ™‚é–“ã®è¨ˆç®—ã‚’å¤‰æ›´
                const durationLv = upgradeLevels.drone_up || 0;
                // åŸºæœ¬300ãƒ•ãƒ¬ãƒ¼ãƒ  * (1 + 0.1 * Lv)
                this.life = 300 * (1 + durationLv * 0.1);
                
                this.hitCooldowns = [];
            }
        }

        update() {
            this.life--;
            
            if(this.type === 'drone') {
                for(let k = this.hitCooldowns.length - 1; k >= 0; k--) {
                    this.hitCooldowns[k].timer--;
                    if(this.hitCooldowns[k].timer <= 0) {
                        this.hitCooldowns.splice(k, 1);
                    }
                }
            }

            if(this.type === 'missile') {
                this.trail.push({x:this.x, y:this.y});
                if(this.trail.length > 5) this.trail.shift();

                if (this.target && enemies.includes(this.target)) {
                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    const angle = Math.atan2(dy, dx);
                    this.vx = this.vx * 0.9 + Math.cos(angle) * 1.0;
                    this.vy = this.vy * 0.9 + Math.sin(angle) * 1.0;
                } else {
                    this.target = getClosestEnemy(this.x, this.y);
                }
                const vel = Math.hypot(this.vx, this.vy);
                if(vel > this.speed) {
                    this.vx = (this.vx / vel) * this.speed;
                    this.vy = (this.vy / vel) * this.speed;
                }
                this.x += this.vx;
                this.y += this.vy;

            } else if(this.type === 'machinegun') {
                this.x += this.vx;
                this.y += this.vy;

            } else if(this.type === 'drone') {
                this.angle += this.speed;
                this.orbitDist += 0.15; 
                this.x = player.x + Math.cos(this.angle) * this.orbitDist;
                this.y = player.y + Math.sin(this.angle) * this.orbitDist;
                
                this.trail.push({x:this.x, y:this.y});
                if(this.trail.length > 10) this.trail.shift();
            }
        }

        draw() {
            if(this.trail.length > 0) {
                ctx.strokeStyle = this.color;
                ctx.globalAlpha = 0.5;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.trail[0].x, this.trail[0].y);
                for(let t of this.trail) ctx.lineTo(t.x, t.y);
                ctx.stroke();
                ctx.globalAlpha = 1.0;
            }

            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    class AreaEffect {
        constructor(x, y, type, level) {
            this.x = x;
            this.y = y;
            this.type = type;
            this.level = level;
            this.timer = 0;
            
            if(type === 'shockwave') {
                this.maxRadius = 50 + level * 15;
                this.duration = 20; 
                this.currentRadius = 0;
            } else if(type === 'gravity') {
                // â˜…å¤‰æ›´: ç¯„å›²ã¨æŒç¶šæ™‚é–“ã‚’æ¸›å°‘ (ãƒŠãƒ¼ãƒ•)
                // åŠå¾„: 60->50, å¢—åŠ ç‡ãƒ€ã‚¦ãƒ³
                // æŒç¶š: 180->120 (2ç§’)
                this.maxRadius = 90 + level * 5; 
                this.duration = 580 + level * 20; 
                this.currentRadius = this.maxRadius;
            }
        }
        
        update(dt) {
            this.timer++;
            
            if(this.type === 'shockwave') {
                this.currentRadius = (this.timer / this.duration) * this.maxRadius;
                
                // --- æ•µã¸ã®å¹²æ¸‰ (æ—¢å­˜å‡¦ç†) ---
                enemies.forEach(e => {
                    const dx = e.x - this.x;
                    const dy = e.y - this.y;
                    const dist = Math.hypot(dx, dy);
                    if(dist < this.currentRadius && dist > this.currentRadius - 10) {
                        const pushPower = 10;
                        e.x += (dx/dist) * pushPower;
                        e.y += (dy/dist) * pushPower;

                        const baseDmg = this.level;
                        e.hp -= getDamage(baseDmg); 
                        
                        if(e.hp <= 0 && !e.dead) {
                             e.dead = true; 
                        }
                    }
                });

                // --- â˜…è¿½åŠ : æ•µå¼¾ã®æ¶ˆå» (é˜²å¾¡æ©Ÿèƒ½) ---
                for(let i = enemyProjectiles.length - 1; i >= 0; i--) {
                    const ep = enemyProjectiles[i];
                    const dist = Math.hypot(ep.x - this.x, ep.y - this.y);
                    
                    // è¡æ’ƒæ³¢ã®å†…å´ã«å…¥ã£ãŸå¼¾ã‚’æ¶ˆã™
                    if(dist < this.currentRadius) {
                        // æ¶ˆæ»…æ™‚ã«ç™½ã„ç«èŠ±ã‚’æ•£ã‚‰ã™æ¼”å‡º
                        particles.push(new Particle(ep.x, ep.y, '#ffffff', 3, 15));
                        
                        enemyProjectiles.splice(i, 1);
                    }
                }

            } else if(this.type === 'gravity') {
                enemies.forEach(e => {
                    const dist = Math.hypot(e.x - this.x, e.y - this.y);
                    if(dist < this.maxRadius) {
                        e.slowTimer = 100;
                        if(this.timer % 10 === 0) {
                            const baseDmg = 0.2 + (this.level * 0.1); 
                            e.hp -= getDamage(baseDmg); 
                            if(e.hp <= 0) e.dead = true;
                        }
                    }
                });
            }
        }

        draw() {
            if(this.type === 'shockwave') {
                ctx.strokeStyle = `rgba(52, 152, 219, ${1 - this.timer/this.duration})`;
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.currentRadius, 0, Math.PI * 2);
                ctx.stroke();
            } else if(this.type === 'gravity') {
                ctx.fillStyle = `rgba(155, 89, 182, 0.2)`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.maxRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = `rgba(155, 89, 182, 0.5)`;
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }
    }

    class Particle {
        constructor(x, y, color, speed, life) {
            this.x = x;
            this.y = y;
            this.color = color;
            this.life = life;
            this.maxLife = life;
            const angle = Math.random() * Math.PI * 2;
            const spd = Math.random() * speed;
            this.vx = Math.cos(angle) * spd;
            this.vy = Math.sin(angle) * spd;
            this.size = Math.random() * 3 + 1;
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.life--;
            this.vx *= 0.95;
            this.vy *= 0.95;
        }
        draw() {
            ctx.globalAlpha = this.life / this.maxLife;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }
    }

    class Jewel {
        constructor(x, y, xp) {
            this.x = x;
            this.y = y;
            this.xp = xp;
            
            // â˜…å¤‰æ›´: é«˜ä¾¡å€¤ã‚¸ã‚§ãƒ ã®å®šç¾©ã‚’è¿½åŠ ã—ã€å·¨å¤§ãªæ•°å€¤ã‚’ã‚µãƒãƒ¼ãƒˆ
            if(this.xp >= 1000) { this.color = '#9b59b6'; this.size = 5; }     // ç´« (ç‰¹å¤§)
            else if(this.xp >= 300) { this.color = '#c0392b'; this.size = 4; } // æ·±ç´… (å¤§)
            else if(this.xp >= 100) { this.color = '#e74c3c'; this.size = 4; } // èµ¤
            else if(this.xp >= 50) { this.color = '#e67e22'; this.size = 3; }   // ã‚ªãƒ¬ãƒ³ã‚¸
            else if(this.xp >= 25) { this.color = '#f39c12'; this.size = 3; }   // é»„
            else if(this.xp >= 10) { this.color = '#f1c40f'; this.size = 2; }   // è–„é»„
            else if(this.xp >= 3) { this.color = '#2ecc71'; this.size = 2; }    // ç·‘
            else { this.color = '#3498db'; this.size = 2; }                     // é’

            this.magnetized = false;
            
            // æ•£ã‚‰ã°ã‚‹æ¼”å‡ºç”¨ã®ç‰©ç†æ¼”ç®—ï¼ˆå¤‰æ›´ãªã—ï¼‰
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 4 + 2; 
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
            this.friction = 0.92; 
        }
        
        // ... (update, draw ãƒ¡ã‚½ãƒƒãƒ‰ã¯å¤‰æ›´ãªã—ã®ãŸã‚çœç•¥)
        
        update() {
            // å¸ã„å¯„ã›å‰ã¯ç‰©ç†æŒ™å‹•ã§æ•£ã‚‰ã°ã‚‹
            if (!this.magnetized) {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= this.friction;
                this.vy *= this.friction;
            }

            // â˜…ä¿®æ­£: ã“ã“ã§ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è·é›¢ã‚’è¨ˆç®—ã™ã‚‹
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const dist = Math.hypot(dx, dy);

            // å›åç¯„å›²ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰é©ç”¨
            const pickupLv = upgradeLevels.pickup || 0;
            const magnetRange = 150 * (1 + pickupLv * 0.15);
            
            if(dist < magnetRange) this.magnetized = true;

            if(this.magnetized) {
                const speed = 12; 
                this.x += (dx / dist) * speed;
                this.y += (dy / dist) * speed;
            }

            // ç”»é¢å¤–ã«å‡ºãªã„ã‚ˆã†ã«åº§æ¨™ã‚’åˆ¶é™ï¼ˆã‚¯ãƒ©ãƒ³ãƒ—ï¼‰
            const margin = this.size + 2;
            if(this.x < margin) this.x = margin;
            if(this.x > GAME_WIDTH - margin) this.x = GAME_WIDTH - margin;
            if(this.y < margin) this.y = margin;
            if(this.y > GAME_HEIGHT - margin) this.y = GAME_HEIGHT - margin;
        }

        draw() {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.moveTo(this.x, this.y - this.size);
            ctx.lineTo(this.x + this.size, this.y);
            ctx.lineTo(this.x, this.y + this.size);
            ctx.lineTo(this.x - this.size, this.y);
            ctx.fill();
        }
    }

    // â˜…å¤‰æ›´: é«˜é¡ã‚¸ã‚§ãƒ ã«è‡ªå‹•ä¸¡æ›¿ã—ã¦ãƒ‰ãƒ­ãƒƒãƒ—æ•°ã‚’å‰Šæ¸›ã™ã‚‹é–¢æ•°
    function spawnGems(x, y, baseXp) {
        // ã‚¸ã‚§ãƒ å¢—åŠ ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰é©ç”¨
        const luckLevel = upgradeLevels.luck || 0;
        let totalXp = Math.floor(baseXp * (1 + luckLevel * 0.2));

        // é€šè²¨ã®ã‚ˆã†ã«å¤§ããªå˜ä½ã‚’å®šç¾©
        const denominations = [1000, 300, 100, 50, 25, 10, 3, 1];

        // å¤§ãã„å˜ä½ã‹ã‚‰é †ã«å¼•ãç®—ã—ã¦ã„ã
        denominations.forEach(val => {
            while(totalXp >= val) {
                // é‡ãªã‚Šã™ããªã„ã‚ˆã†å¾®å¦™ã«ä½ç½®ã‚’ãšã‚‰ã™
                const offsetX = (Math.random() - 0.5) * 10;
                const offsetY = (Math.random() - 0.5) * 10;
                
                jewels.push(new Jewel(x + offsetX, y + offsetY, val));
                totalXp -= val;
            }
        });
    }

    // --- ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•° ---

    function getClosestEnemy(x, y) {
        let nearest = null;
        let minDist = Infinity;
        for(let e of enemies) {
            const d = Math.hypot(e.x - x, e.y - y);
            if(d < minDist) {
                minDist = d;
                nearest = e;
            }
        }
        return nearest;
    }

    function spawnEnemyBatch() {
        // --- é›‘é­šæ•µã®æ•°è¨ˆç®— ---
        let count = 5 + wave * 4;
        
        // â˜…å¤‰æ›´: Wave55ä»¥é™ã€é›‘é­šæ•µã®å¢—ãˆæ–¹ã‚’åŠ é€Ÿã•ã›ã‚‹
        if (wave > 55) {
            // 1Waveã”ã¨ã«ã•ã‚‰ã«+2ä½“è¿½åŠ  (åˆè¨ˆ+4ä½“/Waveãƒšãƒ¼ã‚¹)
            count += (wave - 55) * 4;
        }

        // æ•µå¢—åŠ å‘ªã„é©ç”¨
        const curseLevel = upgradeLevels.curse || 0;
        count = Math.floor(count * (1 + curseLevel * 0.1));

        const margin = 40;
        
        // --- é›‘é­šæ•µã®ã‚¿ã‚¤ãƒ—æŠ½é¸ãƒªã‚¹ãƒˆä½œæˆ ---
        let availableTypes = ['normal','normal','normal'];
        if (wave >= 5) availableTypes.push('fortress','normal'); 
        if (wave >= 15) availableTypes.push('rusher','fortress','normal');
        if (wave >= 25) availableTypes.push('shooter','shooter','normal','normal','fortress','rusher');
        if (wave >= 35) availableTypes.push('summoner','summoner','summoner','normal','fortress','rusher','shooter','shooter');
        if (wave >= 45) availableTypes.push('teleporter','teleporter','teleporter','fortress','rusher','shooter','summoner');
        // ãƒ©ãƒ³ãƒ€ãƒ é¸å‡ºç”¨ã®å…¨ãƒœã‚¹ãƒªã‚¹ãƒˆ
        const allBossTypes = ['fortress', 'rusher', 'shooter', 'summoner', 'teleporter'];

        // --- ãƒœã‚¹å‡ºç¾åˆ¤å®š ---
        // â˜…å¤‰æ›´: Wave55ä»¥é™ã®ç‰¹æ®Šãƒ­ã‚¸ãƒƒã‚¯ã‚’è¿½åŠ 
        
        let bossSpawnCount = 0;

        if (wave >= 55) {
            // Wave55ä»¥é™: 5Waveã”ã¨ã«ãƒœã‚¹å‡ºç¾
            if (wave % 5 === 0) {
                // 55:1ä½“, 60:2ä½“, 65:3ä½“...
                bossSpawnCount = 1 + (wave - 55) / 5;
            }
        } else {
            // Wave54ã¾ã§: 10Waveã”ã¨ã«1ä½“ (æ—¢å­˜ãƒ«ãƒ¼ãƒ«)
            if (wave % 10 === 0) {
                bossSpawnCount = 1;
            }
        }

        // ãƒœã‚¹ç”Ÿæˆãƒ«ãƒ¼ãƒ—
        for(let k=0; k < bossSpawnCount; k++) {
            let bossType = 'normal';

            if (wave >= 55) {
                // ãƒ©ãƒ³ãƒ€ãƒ ãªãƒœã‚¹ã‚’é¸æŠ
                bossType = allBossTypes[Math.floor(Math.random() * allBossTypes.length)];
            } else {
                // æ—¢å­˜ã®å›ºå®šãƒœã‚¹
                if (wave === 10) bossType = 'fortress';
                else if (wave === 20) bossType = 'rusher';
                else if (wave === 30) bossType = 'shooter';
                else if (wave === 40) bossType = 'summoner';
                else if (wave === 50) bossType = 'teleporter';
            }

            let ex = GAME_WIDTH / 2;
            let ey = -margin * 2 - (k * 100); 
            
            if (bossSpawnCount > 1) {
                ex += (Math.random() - 0.5) * 200;
            }

            // æ•µã‚’ç”Ÿæˆã—ã¦ãƒªã‚¹ãƒˆã«è¿½åŠ 
            const newBoss = new Enemy(ex, ey, bossType, true);
            
            // â˜…è¿½åŠ : Wave50ã®ãƒœã‚¹ãªã‚‰ã€Œãƒ©ã‚¹ãƒœã‚¹ã€ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
            if (wave === 50) {
                newBoss.isFinalBoss = true;
            }
            
            enemies.push(newBoss);
        }

        // --- é›‘é­šæ•µç”Ÿæˆ ---
        for(let i=0; i<count; i++) {
            let ex, ey;
            const side = Math.floor(Math.random() * 4);
            if(side === 0) { ex = Math.random() * GAME_WIDTH; ey = -margin; } 
            else if(side === 1) { ex = Math.random() * GAME_WIDTH; ey = GAME_HEIGHT + margin; } 
            else if(side === 2) { ex = -margin; ey = Math.random() * GAME_HEIGHT; } 
            else { ex = GAME_WIDTH + margin; ey = Math.random() * GAME_HEIGHT; } 
            
            const type = availableTypes[Math.floor(Math.random() * availableTypes.length)];
            enemies.push(new Enemy(ex, ey, type, false));
        }
    }

    // â˜…è¿½åŠ : ãƒ€ã‚¤ã‚¹ç²å¾—å‡¦ç†
    function gainDice() {
        const container = document.getElementById('dice-container');
        const currentDiceCount = container.getElementsByClassName('dice').length;

        if (currentDiceCount < 5) {
            // 5å€‹æœªæº€ãªã‚‰ãƒ€ã‚¤ã‚¹ã‚’è¿½åŠ 
            const newIndex = currentDiceCount;
            const newDice = document.createElement('div');
            // åˆæœŸè¡¨ç¤ºç”¨
            newDice.className = 'dice face-1'; 
            newDice.id = `dice-${newIndex}`;
            newDice.innerHTML = '<div class="pip"></div>';
            container.appendChild(newDice);
            
            // ãƒ€ã‚¤ã‚¹ãƒªã‚¹ãƒˆã‚’æ›´æ–°ï¼ˆã“ã“é‡è¦ï¼‰
            refreshDiceList();
        } else {
            // 5å€‹ã‚ã‚‹ãªã‚‰å…¨ã‚¹ã‚­ãƒ«ã®ãƒ¬ãƒ™ãƒ«ã‚’+2
            diceSlots.forEach(slot => {
                slot.level += 2;
            });
            updateSkillList(); // UIæ›´æ–°
            
            // æ¼”å‡ºï¼ˆãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ç”»é¢ã®ã‚ˆã†ãªã‚‚ã®ã‚’å‡ºã™ã‹ã€ç°¡æ˜“çš„ãªé€šçŸ¥ï¼‰
            // ã“ã“ã§ã¯ç°¡æ˜“çš„ã«ãƒ­ã‚°å‡ºåŠ›ã‚„ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆæœ¬æ¥ã¯ç”»é¢ã«æ–‡å­—ã‚’å‡ºã™ã®ãŒè¦ªåˆ‡ï¼‰
            createExplosion(player.x, player.y); // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒå…‰ã‚‹çš„ãªæ¼”å‡ºä»£ç”¨
        }
    }

    // â˜…è¿½åŠ : DOMè¦ç´ ã®ãƒªã‚¹ãƒˆã‚’å†å–å¾—ã™ã‚‹é–¢æ•°
    function refreshDiceList() {
        // domDiceDivs ã¯ const ã§ã¯ãªã let ã«å¤‰æ›´ã™ã‚‹ã‹ã€é…åˆ—ã®ä¸­èº«ã‚’å…¥ã‚Œæ›¿ãˆã‚‹å¿…è¦ãŒã‚ã‚‹
        // æ—¢å­˜ã‚³ãƒ¼ãƒ‰ã® domDiceDivs ã¯ Array.from(...) ã§ç”Ÿæˆã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã®å®šç¾©ã‚’å¤‰æ›´ã™ã‚‹ã»ã†ãŒå®‰å…¨ã§ã™ã€‚
        
        // â€»æ³¨æ„: ä¸‹è¨˜ã®æ‰‹é †6ã§ domDiceDivs ã‚’ let ã«å¤‰æ›´ã—ã¦ãã ã•ã„ã€‚
        domDiceDivs = Array.from(document.querySelectorAll('#dice-container .dice'));
    }

    function createExplosion(x, y) {
        for(let i=0; i<8; i++) particles.push(new Particle(x, y, '#ffaa00', 3, 20));
        for(let i=0; i<4; i++) particles.push(new Particle(x, y, '#ffffff', 2, 10));
    }

    // â˜…è¿½åŠ : ãƒŸã‚µã‚¤ãƒ«ç”¨ã®å¤§ããªçˆ†ç™º
    function createMissileExplosion(x, y) {
        // èµ¤ãã€å¤§ããã€æ•°å¤šã
        for(let i=0; i<16; i++) particles.push(new Particle(x, y, '#e74c3c', 6, 40)); 
        for(let i=0; i<8; i++) particles.push(new Particle(x, y, '#f39c12', 4, 30));
        for(let i=0; i<8; i++) particles.push(new Particle(x, y, '#ffffff', 2, 20));
    }

    // ã‚¹ã‚­ãƒ«ä¸€è¦§ï¼ˆå·¦ã‚µã‚¤ãƒ‰ãƒãƒ¼ï¼‰ã®è¡¨ç¤ºæ›´æ–°
    function updateSkillList() {
        domSkillList.innerHTML = '';
        diceSlots.forEach((slot, index) => {
            const weapon = WEAPON_TYPES[slot.type];
            const card = document.createElement('div');
            card.className = 'skill-card';
            card.style.borderLeftColor = weapon.color;
            
            // ãƒ€ã‚¤ã‚¹ã‚¢ã‚¤ã‚³ãƒ³
            const diceDiv = document.createElement('div');
            diceDiv.className = `dice face-${index + 1}`; // å‡ºç›®ã¯index+1
            // ãƒ”ãƒƒãƒ—ï¼ˆç‚¹ï¼‰ã®ç”Ÿæˆ
            const pipCount = index + 1;
            for(let i=0; i<pipCount; i++) {
                const pip = document.createElement('div');
                pip.className = 'pip';
                diceDiv.appendChild(pip);
            }
            
            card.appendChild(diceDiv);
            card.innerHTML += `
                <div class="skill-info">
                    <div class="skill-title">
                        <span style="color:${weapon.color}">${weapon.name}</span>
                        <span class="skill-level">Lv.${slot.level}</span>
                    </div>
                    <div class="skill-desc">${weapon.desc}</div>
                </div>
            `;
            domSkillList.appendChild(card);
        });
    }

    function updateHpUI() {
        const dispHp = player.hp.toFixed(1); 
        
        // â˜…å¤‰æ›´: å›å¾©ã‚¹ãƒ”ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºã«è¿½åŠ 
        // ç¾åœ¨ã®ãƒ¬ãƒ™ãƒ« Ã— 2 ãŒç§’é–“å›å¾©é‡
        const regenRate = (upgradeLevels.regen || 0) * 0.5;
        // å›å¾©é‡ãŒã‚ã‚‹å ´åˆã ã‘ (+X/s) ã¨è¡¨ç¤º
        const regenText = regenRate > 0 ? ` (+${regenRate}/s)` : '';
        
        domHpText.innerText = `${dispHp} / ${player.maxHp}${regenText}`;
        
        const ratio = (player.hp / player.maxHp) * 100;
        domHpBar.style.width = Math.max(0, ratio) + '%';
        if(ratio < 30) domHpBar.style.backgroundColor = '#e74c3c'; 
        else domHpBar.style.backgroundColor = '#2ecc71'; 
    }

    function updateXpUI() {
        domXpText.innerText = `${currentXp} / ${nextLevelXp}`;
        const p = (currentXp / nextLevelXp) * 100;
        domLevelBar.style.width = p + '%';
    }

    function updateDice(dt) {
        // è¿½åŠ : æ•µãŒã„ãªã„ã¨ãã¯ã‚¿ã‚¤ãƒãƒ¼ã‚’é€²ã‚ãªã„
        if(enemies.length === 0) return;

        // â˜…å¤‰æ›´: ãƒ€ã‚¤ã‚¹åŠ é€Ÿã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã®é©ç”¨
        // Lvã”ã¨ã«10%çŸ­ç¸® (Lv5ã§50%çŸ­ç¸®)
        const speedLevel = upgradeLevels.speed || 0;
        const reductionRatio = speedLevel * 0.1;
        const currentInterval = DICE_ROLL_INTERVAL * (1 - reductionRatio);

        diceTimer += dt;
        if(diceTimer >= currentInterval) {
            diceTimer = 0;
            rollDice();
        }
    }

    // æ­¦å™¨ç™ºå°„ãƒ­ã‚¸ãƒƒã‚¯
    function fireWeapon(type, level) {
        if(type === 'missile') {
            const count = level * 2;
            const target = getClosestEnemy(player.x, player.y);
            if(target || enemies.length > 0) {
                for(let i=0; i<count; i++) {
                    setTimeout(() => {
                        // â˜…è¿½åŠ : åœæ­¢ä¸­ãªã‚‰æ’ƒãŸãªã„
                        if (isLevelUp || isPaused || isGameOver) return;

                        playSound('missile', 0.2); 
                        projectiles.push(new Projectile(player.x, player.y, 'missile', level, target));
                    }, i*60);
                }
            }
        } else if(type === 'machinegun') {
            const count = level * 8; 
            if(enemies.length > 0) {
                for(let i=0; i<count; i++) {
                    setTimeout(() => {
                        // â˜…è¿½åŠ : åœæ­¢ä¸­ãªã‚‰æ’ƒãŸãªã„
                        if (isLevelUp || isPaused || isGameOver) return;

                        const currentTarget = getClosestEnemy(player.x, player.y);
                        playSound('machinegun', 0.1); 
                        projectiles.push(new Projectile(player.x, player.y, 'machinegun', level, currentTarget));
                    }, i*30);
                }
            }
            
        } else if(type === 'shockwave') {
            const bonusCount = upgradeLevels.shock_up || 0;
            const count = 1 + bonusCount;
            
            const interval = 350; 
            for(let i=0; i<count; i++) {
                setTimeout(() => {
                    // â˜…è¿½åŠ : åœæ­¢ä¸­ãªã‚‰æ’ƒãŸãªã„
                    if (isLevelUp || isPaused || isGameOver) return;

                    if(!isGameOver) {
                        playSound('shockwave');
                        areaEffects.push(new AreaEffect(player.x, player.y, 'shockwave', level));
                    }
                }, i * interval);
            }

        } else if(type === 'drone') {
            const count = 1 + level; 
            for(let i=0; i<count; i++) {
                setTimeout(() => {
                    // â˜…è¿½åŠ : åœæ­¢ä¸­ãªã‚‰å‡ºã•ãªã„
                    if (isLevelUp || isPaused || isGameOver) return;

                    playSound('drone');
                    projectiles.push(new Projectile(player.x, player.y, 'drone', level, null));
                }, i*100);
            }

        } else if(type === 'gravity') {
            // â˜…å¤‰æ›´: ã‚°ãƒ©ãƒ“ãƒ†ã‚£å°‚ç”¨ã®éŸ³ã‚’é³´ã‚‰ã™
            playSound('gravity'); 
            
            const rx = Math.random() * (GAME_WIDTH - 100) + 50;
            const ry = Math.random() * (GAME_HEIGHT - 100) + 50;
            areaEffects.push(new AreaEffect(rx, ry, 'gravity', level));
        }
    }

    function rollDice() {
        domDiceDivs.forEach((div, index) => {
            div.classList.add('rolling');
            const spinInterval = setInterval(() => {
                const randomFace = Math.floor(Math.random() * 6) + 1;
                setDiceFace(div, randomFace);
                div.classList.add('rolling'); 
            }, 80);

            const stopDelay = 600 + (index * 150);
            setTimeout(() => {
                clearInterval(spinInterval);
                div.classList.remove('rolling');
                
                const resultFace = Math.floor(Math.random() * 6) + 1;
                setDiceFace(div, resultFace);

                // â˜…è¿½åŠ : ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ä¸­ã€ãƒãƒ¼ã‚ºä¸­ã€ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ãªã‚‰ã“ã“ã§ä¸­æ–­ã—ã€æ­¦å™¨ã‚’ç™ºå‹•ã—ãªã„
                if (isLevelUp || isPaused || isGameOver) return;

                const slotIndex = resultFace - 1;
                const slotData = diceSlots[slotIndex];
                
                fireWeapon(slotData.type, slotData.level);

            }, stopDelay);
        });
    }

    function updateWave(dt) {
        waveTimer += dt;

        // â˜…å¤‰æ›´: WAVEçŸ­ç¸®ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰é©ç”¨
        // Lvã”ã¨ã«1ç§’(1000ms)çŸ­ç¸®
        const timeLevel = upgradeLevels.time || 0;
        const reductionMs = timeLevel * 1000;
        const currentWaveInterval = Math.max(5000, WAVE_INTERVAL - reductionMs); // æœ€ä½5ç§’ã¯ç¢ºä¿

        const ratio = 1 - (waveTimer / currentWaveInterval);
        domWaveBar.style.width = Math.max(0, ratio * 100) + '%';
        
        const remainingSec = Math.max(0, (currentWaveInterval - waveTimer) / 1000);
        domWaveTimerText.innerText = remainingSec.toFixed(2) + 'sec.';

        if(waveTimer >= currentWaveInterval) {
            waveTimer = 0;
            wave++;
            domWave.innerText = wave;
            spawnEnemyBatch();
        }
    }

    function gainXp(amount) {
        currentXp += amount;
        score += amount; // â˜…è¿½åŠ : ã‚¹ã‚³ã‚¢åŠ ç®—

        if(currentXp >= nextLevelXp) {
            currentXp -= nextLevelXp;
            level++;
            nextLevelXp = Math.floor(nextLevelXp * 1.3);
            domLevel.innerText = level;
            triggerLevelUp();
        }
        updateXpUI();
    }

    function resolveEnemyCollisions() {
        for (let i = 0; i < enemies.length; i++) {
            for (let j = i + 1; j < enemies.length; j++) {
                const e1 = enemies[i];
                const e2 = enemies[j];
                const dx = e1.x - e2.x;
                const dy = e1.y - e2.y;
                const dist = Math.hypot(dx, dy);
                
                // â˜…ä¿®æ­£: å½“ãŸã‚Šåˆ¤å®šã‚’ (ã‚µã‚¤ã‚º/2 + ã‚µã‚¤ã‚º/2) ã«åˆã‚ã›ã‚‹
                // ä»Šã¾ã§ã¯ (e1.size + e2.size) ã ã£ãŸã®ã§2å€ã®è·é›¢ã§åç™ºã—ã¦ã„ã¾ã—ãŸ
                const minDist = (e1.size/2 + e2.size/2) * 0.9; 
                
                if (dist < minDist && dist > 0) {
                    const overlap = minDist - dist;
                    const pushX = (dx / dist) * (overlap / 2);
                    const pushY = (dy / dist) * (overlap / 2);
                    e1.x += pushX * 0.5;
                    e1.y += pushY * 0.5;
                    e2.x -= pushX * 0.5;
                    e2.y -= pushY * 0.5;
                }
            }
        }
    }

    function update(dt) {
        if(isGameOver || isLevelUp) return;

        // Player Move
        if(keys.w && player.y > player.size) player.y -= PLAYER_SPEED;
        if(keys.s && player.y < GAME_HEIGHT - player.size) player.y += PLAYER_SPEED;
        if(keys.a && player.x > player.size) player.x -= PLAYER_SPEED;
        if(keys.d && player.x < GAME_WIDTH - player.size) player.x += PLAYER_SPEED;

        if(upgradeLevels.regen > 0) {
            const regenAmount = (upgradeLevels.regen * 0.5) * (dt / 1000);
            // æœ€å¤§HPã‚’è¶…ãˆãªã„ã‚ˆã†ã«å›å¾©
            if (player.hp < player.maxHp) {
                player.hp += regenAmount;
                if (player.hp > player.maxHp) player.hp = player.maxHp;
                updateHpUI(); // UIã‚’æ›´æ–°ã—ã¦æ•°å€¤ã«åæ˜ ã•ã›ã‚‹
            }
        }

        updateDice(dt);
        updateWave(dt);

        enemies.forEach(e => e.update(dt));
        resolveEnemyCollisions();

        // Projectiles update
        projectiles.forEach((m, i) => {
            m.update();
            if(m.life <= 0 || m.x < -100 || m.x > GAME_WIDTH+100 || m.y < -100 || m.y > GAME_HEIGHT+100) {
                projectiles.splice(i, 1);
            } else {
                // Hit check
                for(let j=enemies.length-1; j>=0; j--) {
                    const e = enemies[j];
                    const dist = Math.hypot(m.x - e.x, m.y - e.y);
                    
                    // â˜…ä¿®æ­£: æ•µã®åŠå¾„ã‚’ e.size/2 ã¨ã—ã¦è¨ˆç®—
                    if(dist < (e.size/2) + m.size) {
                        
                        // --- ãƒŸã‚µã‚¤ãƒ« (ç€å¼¾ = çˆ†ç™º) ---
                        if(m.type === 'missile') {
                            createMissileExplosion(m.x, m.y);
                            
                            // â˜…è¿½åŠ : çˆ†ç™ºéŸ³ (å°‘ã—å¤§ãã‚)
                            playSound('explosion', 0.6); 

                            // (ä»¥ä¸‹ãƒ€ãƒ¡ãƒ¼ã‚¸è¨ˆç®—å‡¦ç†...å¤‰æ›´ãªã—)
                            const missileLv = upgradeLevels.missile_ex || 0;
                            const blastRadius = 80 * (1 + missileLv * 0.15);
                            enemies.forEach(subE => {
                                const blastDist = Math.hypot(m.x - subE.x, m.y - subE.y);
                                if(blastDist < blastRadius) {
                                    subE.hp -= getDamage(4);
                                    if(subE.hp <= 0) subE.dead = true;
                                }
                            });
                            projectiles.splice(i, 1);
                            break; 
                        }
                        
                        // --- ãƒ‰ãƒ­ãƒ¼ãƒ³ (æ¥è§¦) ---
                        else if(m.type === 'drone') {
                            const alreadyHit = m.hitCooldowns.find(h => h.enemy === e);
                            if(alreadyHit) continue; 
                            
                            // â˜…è¿½åŠ : ãƒ’ãƒƒãƒˆéŸ³ (é€£ç¶šã™ã‚‹ã®ã§æ§ãˆã‚ã«ã€ãƒ”ãƒƒãƒã‚’æºã‚‰ã™)
                            playSound('hit', 0.2);

                            m.hitCooldowns.push({ enemy: e, timer: 15 });
                            e.hp -= getDamage(4);
                            createExplosion(m.x, m.y);
                            if(e.hp <= 0) e.dead = true;
                            break;
                        }
                        
                        // --- ãƒã‚·ãƒ³ã‚¬ãƒ³ (ç€å¼¾) ---
                        else if(m.type === 'machinegun') {
                            if(m.hitEnemies.includes(e)) continue;

                            // â˜…è¿½åŠ : ãƒ’ãƒƒãƒˆéŸ³ (é€£å°„ç³»ãªã®ã§æ§ãˆã‚ã«)
                            playSound('hit', 0.2);

                            e.hp -= getDamage(4); 
                            createExplosion(m.x, m.y);
                            if(e.hp <= 0) e.dead = true;

                            m.hitEnemies.push(e);
                            
                            const pierceBonus = upgradeLevels.mg_pierce || 0;
                            const maxHits = 2 + pierceBonus;

                            if(m.hitEnemies.length >= maxHits) {
                                projectiles.splice(i, 1);
                                break;
                            }
                            break; 
                        }

                        // --- ãã®ä»– ---
                        else {
                            e.hp -= getDamage(4);
                            createExplosion(m.x, m.y);
                            projectiles.splice(i, 1);
                            if(e.hp <= 0) e.dead = true;
                            break;
                        }
                    }
                }
            }
        });

        // Area Effects update
        areaEffects.forEach((a, i) => {
            a.update(dt);
            if(a.type === 'shockwave' && a.timer >= a.duration) areaEffects.splice(i, 1);
            else if(a.type === 'gravity' && a.timer >= a.duration) areaEffects.splice(i, 1);
        });

        // Dead enemies cleanup
        for(let i=enemies.length-1; i>=0; i--) {
            if(enemies[i].dead) {
                if (enemies[i].isFinalBoss) {
                    hasDefeatedWave50Boss = true;
                }
                if(enemies[i].isBoss) {
                    diceDrops.push(new DiceDrop(enemies[i].x, enemies[i].y));
                    spawnGems(enemies[i].x, enemies[i].y, 1000); 
                    for(let k=0; k<5; k++) createExplosion(enemies[i].x + (Math.random()-0.5)*40, enemies[i].y + (Math.random()-0.5)*40);
                } else {
                    // â˜…ä¿®æ­£: noGemãƒ•ãƒ©ã‚°ãŒãªã‘ã‚Œã°ã‚¸ã‚§ãƒ ã‚’è½ã¨ã™
                    if (!enemies[i].noGem) {
                        const xpAmount = Math.max(1, Math.floor(enemies[i].maxHp * 0.8));
                        spawnGems(enemies[i].x, enemies[i].y, xpAmount);
                    }
                }
                enemies.splice(i, 1);
            }
        }

        // Jewels update
        jewels.forEach((j, i) => {
            j.update();
            const dist = Math.hypot(player.x - j.x, player.y - j.y);
            if(dist < player.size + j.size + 2) {
                gainXp(j.xp);
                playSound('gem', 0.3); // ã‚¸ã‚§ãƒ å›åéŸ³
                jewels.splice(i, 1);
            }
        });

        // DiceDrops update
        diceDrops.forEach((d, i) => {
            d.update();
            const dist = Math.hypot(player.x - d.x, player.y - d.y);
            if(dist < player.size + d.size + 2) {
                gainDice();
                diceDrops.splice(i, 1);
            }
        });

        particles.forEach((p, i) => {
            p.update();
            if(p.life <= 0) particles.splice(i, 1);
        });

        for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
            const ep = enemyProjectiles[i];
            ep.update();
            
            // ç”»é¢å¤–å‰Šé™¤
            if (ep.x < -50 || ep.x > GAME_WIDTH + 50 || ep.y < -50 || ep.y > GAME_HEIGHT + 50 || ep.life <= 0) {
                enemyProjectiles.splice(i, 1);
                continue;
            }

            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è¡çª
            const dist = Math.hypot(player.x - ep.x, player.y - ep.y);
            if (dist < player.size + ep.size) {
                player.hp -= 10; // å¼¾ã®ãƒ€ãƒ¡ãƒ¼ã‚¸
                enemyProjectiles.splice(i, 1);
                updateHpUI();
                
                // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼åˆ¤å®šã¯ã“ã®å¾Œã®å…±é€šå‡¦ç†ã«ä»»ã›ã‚‹ã‹ã€ã“ã“ã§æ›¸ã
                // â˜…è¿½åŠ : ã“ã“ã§ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼åˆ¤å®šã‚’è¡Œã†
                if(player.hp <= 0) {
                    triggerGameOver();
                }
            }
        }

        // Player Damage
        let isTakingDamage = false;
        for(let e of enemies) {
            const dist = Math.hypot(player.x - e.x, player.y - e.y);
            
            // â˜…ä¿®æ­£: æ•µã®åŠå¾„ã‚’ e.size/2 ã¨ã—ã¦è¨ˆç®—
            if(dist < player.size + (e.size/2)) {
                isTakingDamage = true;
                const damage = e.dps * (dt / 1000);
                player.hp -= damage;
            }
        }
        if(isTakingDamage) {
            updateHpUI(); // HPãƒãƒ¼æ›´æ–°
            
            // â˜…ä¿®æ­£: é–¢æ•°å‘¼ã³å‡ºã—ã«å¤‰æ›´
            if(player.hp <= 0) {
                triggerGameOver();
            }
        }
    }

    function draw() {
        ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        // Grid
        ctx.strokeStyle = '#222';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for(let x=0; x<GAME_WIDTH; x+=60) { ctx.moveTo(x,0); ctx.lineTo(x, GAME_HEIGHT); }
        for(let y=0; y<GAME_HEIGHT; y+=60) { ctx.moveTo(0,y); ctx.lineTo(GAME_WIDTH, y); }
        ctx.stroke();

        areaEffects.forEach(a => a.draw());
        jewels.forEach(j => j.draw());
        diceDrops.forEach(d => d.draw()); // â˜…è¿½åŠ : ãƒ€ã‚¤ã‚¹ã®æç”»
        enemies.forEach(e => e.draw());
        enemyProjectiles.forEach(ep => ep.draw());
        projectiles.forEach(m => m.draw());
        particles.forEach(p => p.draw());

        // Player
        ctx.shadowBlur = 10;
        ctx.shadowColor = player.color;
        ctx.fillStyle = player.color;
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.size, 0, Math.PI*2);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.size + 4, 0, Math.PI*2);
        ctx.stroke();
    }

    function gameLoop(timestamp) {
        if(!isGameRunning) return; // ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ç­‰ã§ã¯ãƒ«ãƒ¼ãƒ—åœæ­¢

        animationFrameId = requestAnimationFrame(gameLoop);

        if(isPaused) return;

        let dt = timestamp - lastTime;
        if(dt > 100) dt = 16; 
        lastTime = timestamp;

        update(dt);
        draw();
    }

    function init() {
        // æœ€åˆã¯ã‚¿ã‚¤ãƒˆãƒ«ã‚’è¡¨ç¤º
        showTitle();
    }



    // --- ã‚·ãƒ¼ãƒ³ç®¡ç† ---

    function showTitle() {
        isGameRunning = false;
        isPaused = false;
        isGameOver = false;
        
        document.getElementById('title-screen').style.display = 'flex';
        screenGameOver.style.display = 'none';
        screenPause.style.display = 'none';
        screenLevelUp.style.display = 'none';

        const cr = parseInt(localStorage.getItem('diceSurvivors_credits')) || 0;
        document.getElementById('ending-screen').style.display = 'none';
        document.getElementById('title-credits').innerText = cr;

        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        // â˜…å¤‰æ›´: ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãŒèµ·å‹•ä¸­('running')ã®ã¨ãã ã‘å†ç”Ÿã™ã‚‹
        // (ã¾ã åœæ­¢ä¸­ãªã‚‰ã€ã“ã®å¾Œã® unlockAudio ã§ã‚¯ãƒªãƒƒã‚¯æ™‚ã«å†ç”Ÿã•ã‚Œã‚‹)
        if (audioCtx.state === 'running') {
            playBgm('bgm_title');
        }
    }

    function openShop() {
        document.getElementById('title-screen').style.display = 'none';
        document.getElementById('shop-screen').style.display = 'flex';
        renderShop();
    }

    function closeShop() {
        document.getElementById('shop-screen').style.display = 'none';
        showTitle();
    }

    function renderShop() {
        // ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆè¡¨ç¤ºæ›´æ–°
        document.getElementById('shop-credits-display').innerText = totalCredits;

        const container = document.getElementById('shop-container');
        container.innerHTML = '';

        Object.values(UPGRADE_CONFIG).forEach(item => {
            const currentLv = upgradeLevels[item.id] || 0;
            const isMax = currentLv >= item.maxLevel;
            const nextCost = isMax ? 0 : item.costs[currentLv];
            const canAfford = totalCredits >= nextCost;

            const card = document.createElement('div');
            card.className = 'shop-card';
            card.innerHTML = `
                <div class="shop-card-header">
                    <span class="shop-item-name">${item.name}</span>
                    <span class="shop-item-level">Lv.${currentLv} / ${item.maxLevel}</span>
                </div>
                <div class="shop-item-desc">${item.desc}</div>
                <button class="shop-buy-btn" onclick="buyUpgrade('${item.id}')" ${isMax || !canAfford ? 'disabled' : ''}>
                    <span>${isMax ? 'SOLD OUT' : 'BUY'}</span>
                    <span class="shop-cost">${isMax ? '' : nextCost} CR</span>
                </button>
            `;
            container.appendChild(card);
        });

        
    }

    // â˜…è¿½åŠ : å…¨é¡æ‰•ã„æˆ»ã—æ©Ÿèƒ½
    function refundUpgrades() {
        if(!confirm("å…¨ã¦ã®ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã‚’è§£é™¤ã—ã¦ã€ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆã‚’æ‰•ã„æˆ»ã—ã¾ã™ã‹ï¼Ÿ")) return;

        let refundTotal = 0;

        // å…¨ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰é …ç›®ã‚’èµ°æŸ»
        Object.keys(UPGRADE_CONFIG).forEach(key => {
            const item = UPGRADE_CONFIG[key];
            const currentLevel = upgradeLevels[key] || 0;
            
            // ç¾åœ¨ã®ãƒ¬ãƒ™ãƒ«ã«è‡³ã‚‹ã¾ã§ã«ã‹ã‹ã£ãŸã‚³ã‚¹ãƒˆã‚’åˆç®—
            for(let i=0; i < currentLevel; i++) {
                refundTotal += item.costs[i];
            }
            
            // ãƒ¬ãƒ™ãƒ«ã‚’ãƒªã‚»ãƒƒãƒˆ
            upgradeLevels[key] = 0;
        });

        // ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆè¿”å´
        totalCredits += refundTotal;

        // ä¿å­˜
        localStorage.setItem('diceSurvivors_credits', totalCredits);
        localStorage.setItem('diceSurvivors_upgrades', JSON.stringify(upgradeLevels));

        // ç”»é¢æ›´æ–°
        renderShop();
        alert(`${refundTotal} ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆãŒæ‰•ã„æˆ»ã•ã‚Œã¾ã—ãŸã€‚`);
    }

    function buyUpgrade(id) {
        const item = UPGRADE_CONFIG[id];
        const currentLv = upgradeLevels[id] || 0;
        
        if(currentLv >= item.maxLevel) return;

        const cost = item.costs[currentLv];
        if(totalCredits >= cost) {
            // è³¼å…¥å‡¦ç†
            totalCredits -= cost;
            upgradeLevels[id] = currentLv + 1;
            
            // ä¿å­˜
            localStorage.setItem('diceSurvivors_credits', totalCredits);
            localStorage.setItem('diceSurvivors_upgrades', JSON.stringify(upgradeLevels));
            
            // å†æç”»
            renderShop();
        }
    }

    function resetGame() {
        // å¤‰æ•°åˆæœŸåŒ–
        level = 1;
        currentXp = 0;
        nextLevelXp = 50;
        wave = 1;
        score = 0;
        diceTimer = 0;
        waveTimer = 0;
        lastTime = performance.now();

        hasDefeatedWave50Boss = false;
        
        // â˜…å¤‰æ›´: HPã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰åæ˜  (Base 100 + Lv * 20)
        const bonusHp = (upgradeLevels.hp || 0) * 20;
        player.maxHp = 100 + bonusHp;
        player.hp = player.maxHp;
        player.x = GAME_WIDTH / 2;
        player.y = GAME_HEIGHT / 2;

        enemies = [];
        projectiles = [];
        enemyProjectiles = []; // â˜…è¿½åŠ : åˆæœŸåŒ–
        particles = [];
        jewels = [];
        diceDrops = [];
        areaEffects = [];

        // ãƒ€ã‚¤ã‚¹ã‚¹ãƒ­ãƒƒãƒˆåˆæœŸåŒ–
        diceSlots = [
            { type: 'missile', level: 1 },
            { type: 'missile', level: 2 },
            { type: 'missile', level: 3 },
            { type: 'missile', level: 4 },
            { type: 'missile', level: 5 },
            { type: 'missile', level: 6 }
        ];

        // UIåˆæœŸåŒ–
        initUI();
        
        // â˜…å¤‰æ›´: åˆæœŸãƒ€ã‚¤ã‚¹æ•°åæ˜  (Base 1 + Upgrade)
        const container = document.getElementById('dice-container');
        container.innerHTML = '';
        
        const initialDiceCount = 1 + (upgradeLevels.dice || 0); // ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰åˆ†è¿½åŠ 
        
        for(let i=0; i<initialDiceCount; i++) {
            const newDice = document.createElement('div');
            newDice.className = 'dice face-1';
            newDice.id = `dice-${i}`;
            newDice.innerHTML = '<div class="pip"></div>';
            container.appendChild(newDice);
        }
        refreshDiceList();

        spawnEnemyBatch();
    }

    // â˜…è¿½åŠ : æ”»æ’ƒåŠ›ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰é©ç”¨å¾Œã®ãƒ€ãƒ¡ãƒ¼ã‚¸è¨ˆç®—
    function getDamage(baseDamage) {
        const multiplier = 1 + (upgradeLevels.atk || 0) * 0.1; // Lv * 10%
        return baseDamage * multiplier;
    }

    function startGame() {
        playSound('click');
        document.getElementById('title-screen').style.display = 'none';
        playBgm('bgm_game');
        resetGame();
        isGameRunning = true;
        isGameOver = false;
        lastTime = performance.now();
        
        if(animationFrameId) cancelAnimationFrame(animationFrameId);
        gameLoop(performance.now());
    }

    // â˜…è¿½åŠ : ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼å…±é€šå‡¦ç†
    // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã¾ãŸã¯ã‚¯ãƒªã‚¢æ™‚ã®å‡¦ç†
    function triggerGameOver() {
        if(isGameOver) return; 
        
        player.hp = 0;
        isGameOver = true;

        // --- å…±é€š: ã‚¹ã‚³ã‚¢ã¨ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆã®è¨ˆç®—ãƒ»ä¿å­˜ ---
        if(score > highScore) {
            highScore = score;
            localStorage.setItem('diceSurvivors_highScore', highScore);
        }
        totalCredits += score;
        localStorage.setItem('diceSurvivors_credits', totalCredits);


        // --- åˆ†å²åˆ¤å®š ---
        // Wave50ã®ãƒœã‚¹ã‚’å€’ã—ãŸ = Wave51ä»¥ä¸Šã«åˆ°é”ã—ã¦ã„ã‚‹
        if (hasDefeatedWave50Boss) {
            // â˜…ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒ«ãƒ¼ãƒˆ
            playBgm('bgm_ending');
            
            // å€¤ã®ã‚»ãƒƒãƒˆ
            document.getElementById('ed-score').innerText = score;
            document.getElementById('ed-high-score').innerText = highScore;
            document.getElementById('ed-credits').innerText = score;
            
            // ç”»é¢è¡¨ç¤º
            document.getElementById('ending-screen').style.display = 'flex';
            
            // ç´™å¹é›ªé–‹å§‹
            startConfetti();

        } else {
            // â˜…é€šå¸¸ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ãƒ«ãƒ¼ãƒˆ
            playSound('gameover');
            playBgm('bgm_gameover');

            // å€¤ã®ã‚»ãƒƒãƒˆ
            document.getElementById('go-score').innerText = score;
            document.getElementById('go-high-score').innerText = highScore;
            document.getElementById('go-credits').innerText = score;
            
            // ç”»é¢è¡¨ç¤º
            screenGameOver.style.display = 'flex';
        }
    }

    // --- ç´™å¹é›ªç”Ÿæˆé–¢æ•° ---
    function startConfetti() {
        const container = document.getElementById('confetti-container');
        container.innerHTML = ''; // ãƒªã‚»ãƒƒãƒˆ
        
        const colors = ['#e74c3c', '#3498db', '#f1c40f', '#2ecc71', '#9b59b6', '#ecf0f1'];
        
        // 100æšã®ç´™å¹é›ªã‚’ç”Ÿæˆ
        for (let i = 0; i < 100; i++) {
            const el = document.createElement('div');
            el.className = 'confetti';
            
            // ãƒ©ãƒ³ãƒ€ãƒ ãªè‰²ã€ä½ç½®ã€ã‚µã‚¤ã‚º
            el.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
            el.style.left = Math.random() * 100 + '%';
            el.style.top = -10 + 'px'; // ç”»é¢ä¸Šã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆ
            el.style.width = (Math.random() * 10 + 5) + 'px';
            el.style.height = (Math.random() * 5 + 5) + 'px';
            
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š (DOMæ“ä½œã§ç°¡æ˜“ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³)
            const duration = Math.random() * 3 + 2; // 2~5ç§’
            const delay = Math.random() * 5;
            
            el.style.transition = `top ${duration}s linear, transform ${duration}s ease-in-out`;
            el.style.transform = `rotate(${Math.random() * 360}deg)`;
            
            container.appendChild(el);

            // è½ä¸‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
            // (CSS Keyframesã ã¨ãƒ©ãƒ³ãƒ€ãƒ æ€§ãŒå¼±ã„ãŸã‚ã€JSã§å°‘ã—è£œå®Œ)
            setTimeout(() => {
                el.animate([
                    { transform: `translate3d(0,0,0) rotate(0deg)`, opacity: 1 },
                    { transform: `translate3d(${Math.random()*100 - 50}px, 600px, 0) rotate(${Math.random()*720}deg)`, opacity: 0 }
                ], {
                    duration: duration * 1000,
                    delay: delay * 1000,
                    iterations: Infinity
                });
            }, 10);
        }
    }

    function backToTitle() {
        // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç”»é¢ãªã©ã‹ã‚‰ã‚¿ã‚¤ãƒˆãƒ«ã¸
        playBgm('bgm_title');
        showTitle();
    }

    // --- éŸ³é‡ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®ã‚¤ãƒ™ãƒ³ãƒˆ ---
    document.getElementById('title-volume').addEventListener('input', (e) => {
        setGlobalVolume(e.target.value);
    });
    document.getElementById('pause-volume').addEventListener('input', (e) => {
        setGlobalVolume(e.target.value);
    });

    // åˆæœŸåŒ–æ™‚ã«ä¿å­˜ã•ã‚ŒãŸéŸ³é‡ã‚’é©ç”¨ï¼†ã‚µã‚¦ãƒ³ãƒ‰ãƒ­ãƒ¼ãƒ‰
    const savedVol = localStorage.getItem('diceSurvivors_volume');
    if(savedVol !== null) {
        setGlobalVolume(savedVol);
    }
    loadSounds(); // ã‚²ãƒ¼ãƒ é–‹å§‹å‰ã«ãƒ­ãƒ¼ãƒ‰é–‹å§‹

    document.getElementById('title-bgm-volume').addEventListener('input', (e) => {
        setBgmVolume(e.target.value);
    });
    document.getElementById('pause-bgm-volume').addEventListener('input', (e) => {
        setBgmVolume(e.target.value);
    });

    // åˆæœŸåŒ–æ™‚ã«ä¿å­˜ã•ã‚ŒãŸBGMéŸ³é‡ã‚’é©ç”¨
    const savedBgmVol = localStorage.getItem('diceSurvivors_bgm_volume');
    if(savedBgmVol !== null) {
        setBgmVolume(savedBgmVol);
    }

    function unlockAudio() {
        // AudioContextãŒåœæ­¢ä¸­ãªã‚‰å†é–‹ã™ã‚‹
        if (audioCtx.state === 'suspended') {
            audioCtx.resume().then(() => {
                // â˜…æˆåŠŸæ™‚ã®å‡¦ç†: å†é–‹ã«æˆåŠŸã—ãŸã‚‰ã‚¿ã‚¤ãƒˆãƒ«BGMã‚’æµã™
                const titleScreen = document.getElementById('title-screen');
                if (titleScreen.style.display !== 'none') {
                    playBgm('bgm_title');
                }
                console.log("AudioContext resumed successfully!");
            }).catch(e => {
                console.error("Audio resume failed:", e);
            });
        }

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®å‰Šé™¤
        document.removeEventListener('click', unlockAudio);
        document.removeEventListener('keydown', unlockAudio);
        document.removeEventListener('touchstart', unlockAudio);
    }

    // ã‚¯ãƒªãƒƒã‚¯ã€ã‚­ãƒ¼æŠ¼ã—ã€ã‚¿ãƒƒãƒã®ã„ãšã‚Œã‹ã§è§£é™¤
    document.addEventListener('click', unlockAudio);
    document.addEventListener('keydown', unlockAudio);
    document.addEventListener('touchstart', unlockAudio);

    

    init();

</script>
</body>
</html>