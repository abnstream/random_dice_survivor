<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Dice Survivors</title>
    <style>
        :root {
            --bg-color: #222;
            --panel-bg: #111;
            --text-color: #fff;
            --border-color: #fff;
            --accent-red: #e74c3c;
            --accent-green: #2ecc71;
            --accent-blue: #3498db;
            --accent-yellow: #f1c40f;
            --accent-purple: #9b59b6;
            --accent-cyan: #1abc9c;
            --pip-color: #333;
            --pip-red: #e74c3c;
            
            --container-width: 1280px;
            --container-height: 720px;
            --top-bar-height: 90px;
            --sidebar-width: 260px;
        }

        body {
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: 'Segoe UI', 'Meiryo', sans-serif;
            color: var(--text-color);
            user-select: none;
            overflow: hidden;
        }

        #game-container {
            width: var(--container-width);
            height: var(--container-height);
            background-color: var(--panel-bg);
            display: grid;
            grid-template-rows: var(--top-bar-height) 1fr;
            grid-template-columns: var(--sidebar-width) 1fr;
            padding: 15px;
            box-sizing: border-box;
            gap: 15px;
            box-shadow: 0 0 40px rgba(0,0,0,0.5);
            position: relative;
        }

        /* --- 上部バー --- */
        #top-bar {
            grid-row: 1;
            grid-column: 1 / 3;
            display: flex;
            align-items: center;
            gap: 30px;
        }

        #dice-container {
            display: flex;
            gap: 12px;
            padding: 5px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            margin-right: auto;
        }

        .dice {
            width: 56px;
            height: 56px;
            background-color: #fdfdfd;
            border-radius: 10px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.1), 0 4px 6px rgba(0,0,0,0.3);
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            padding: 6px;
            box-sizing: border-box;
            gap: 2px;
            transition: transform 0.2s;
            flex-shrink: 0;
            color: black; /* 数字表示用 */
            font-weight: bold;
            font-size: 24px;
            place-items: center;
        }
        
        .pip {
            background-color: var(--pip-color);
            border-radius: 50%;
            width: 10px;
            height: 10px;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.5);
        }

        /* Face Layouts */
        .face-1 { display: flex; justify-content: center; align-items: center; }
        .face-1 .pip { width: 24px; height: 24px; background-color: var(--pip-red); }
        .face-2 .pip:nth-child(1) { grid-area: 1 / 3; } .face-2 .pip:nth-child(2) { grid-area: 3 / 1; }
        .face-3 .pip:nth-child(1) { grid-area: 1 / 3; } .face-3 .pip:nth-child(2) { grid-area: 2 / 2; } .face-3 .pip:nth-child(3) { grid-area: 3 / 1; }
        .face-4 .pip:nth-child(1) { grid-area: 1 / 1; } .face-4 .pip:nth-child(2) { grid-area: 1 / 3; } .face-4 .pip:nth-child(3) { grid-area: 3 / 1; } .face-4 .pip:nth-child(4) { grid-area: 3 / 3; }
        .face-5 .pip:nth-child(1) { grid-area: 1 / 1; } .face-5 .pip:nth-child(2) { grid-area: 1 / 3; } .face-5 .pip:nth-child(3) { grid-area: 2 / 2; } .face-5 .pip:nth-child(4) { grid-area: 3 / 1; } .face-5 .pip:nth-child(5) { grid-area: 3 / 3; }
        .face-6 .pip:nth-child(1) { grid-area: 1 / 1; } .face-6 .pip:nth-child(2) { grid-area: 1 / 3; } .face-6 .pip:nth-child(3) { grid-area: 2 / 1; } .face-6 .pip:nth-child(4) { grid-area: 2 / 3; } .face-6 .pip:nth-child(5) { grid-area: 3 / 1; } .face-6 .pip:nth-child(6) { grid-area: 3 / 3; }

        .rolling { animation: shake 0.2s infinite; filter: blur(1px); }
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            50% { transform: translate(-1px, -2px) rotate(-5deg); }
            100% { transform: translate(1px, -1px) rotate(5deg); }
        }

        /* Status Bar */
        .status-group { display: flex; flex-direction: column; width: 320px; }
        .status-header-row { display: flex; justify-content: space-between; align-items: flex-end; margin-bottom: 4px; }
        .status-label { font-size: 16px; font-weight: bold; letter-spacing: 1px; color: #ccc; }
        .status-value { font-size: 14px; color: var(--text-color); font-family: monospace; }
        .bar-bg { width: 100%; height: 20px; background: #333; border: 1px solid #666; position: relative; }
        #level-bar-fill { height: 100%; background: linear-gradient(90deg, #2ecc71, #27ae60); width: 0%; transition: width 0.2s; }
        #wave-bar-fill { height: 100%; background: linear-gradient(90deg, #e74c3c, #c0392b); width: 100%; }

        /* --- 左サイドバー (スキル一覧) --- */
        #left-sidebar {
            grid-row: 2;
            grid-column: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow: hidden;
        }
        #skill-list-container {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding-right: 5px;
        }
        #skill-list-container::-webkit-scrollbar { width: 6px; }
        #skill-list-container::-webkit-scrollbar-track { background: #222; }
        #skill-list-container::-webkit-scrollbar-thumb { background: #555; border-radius: 3px; }

        .skill-card {
            background: #eee;
            color: #222;
            padding: 8px;
            display: flex;
            align-items: center;
            border-radius: 6px;
            min-height: 72px;
            box-sizing: border-box;
            border-left: 5px solid #aaa;
            position: relative;
        }
        .skill-card .dice { transform: scale(0.65); margin-right: 2px; border: 1px solid #ccc; }
        .skill-info { display: flex; flex-direction: column; justify-content: center; width: 100%; }
        .skill-title { font-weight: bold; font-size: 14px; color: #000; margin-bottom: 2px; display: flex; justify-content: space-between;}
        .skill-level { font-size: 12px; background: #333; color: white; padding: 1px 4px; border-radius: 4px; }
        .skill-desc { font-size: 10px; color: #555; line-height: 1.2; }

        /* HP表示 */
        #hp-container {
            flex-shrink: 0;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #444;
        }
        .hp-header { display: flex; justify-content: space-between; align-items: baseline; margin-bottom: 5px; font-size: 14px; font-weight: bold; }
        #hp-text { color: var(--accent-green); font-family: monospace; font-size: 16px; }
        .hp-bar-bg { width: 100%; height: 15px; background: #333; border: 1px solid #fff; }
        #hp-bar-fill { width: 100%; height: 100%; background: var(--accent-green); transition: width 0.1s; }

        /* --- ゲームエリア --- */
        #game-viewport-wrapper {
            grid-row: 2;
            grid-column: 2;
            position: relative;
            border: 4px solid var(--border-color);
            box-sizing: border-box;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        canvas { display: block; }

        /* オーバーレイ (ポーズ, ゲームオーバー, レベルアップ) */
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(4px);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 100;
            color: white;
        }
        #game-over-screen { background: rgba(50,0,0,0.9); z-index: 101; }
        h1 { margin: 0 0 20px 0; letter-spacing: 5px; font-size: 40px; }

        /* レベルアップ画面 */
        #level-up-screen { z-index: 110; }
        .level-up-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 80%;
            max-width: 800px;
        }
        .level-up-title { font-size: 32px; font-weight: bold; margin-bottom: 30px; color: var(--accent-green); text-shadow: 0 0 10px var(--accent-green); }
        .level-up-instruction { font-size: 18px; margin-bottom: 20px; }

        /* 3択カード */
        .card-container {
            display: flex;
            gap: 20px;
            width: 100%;
            justify-content: center;
        }
        .choice-card {
            background: #222;
            border: 2px solid #fff;
            border-radius: 8px;
            width: 220px;
            height: 300px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s;
        }
        .choice-card:hover { transform: scale(1.05); background: #333; border-color: var(--accent-green); }
        .choice-name { font-size: 20px; font-weight: bold; margin: 15px 0; text-align: center; border-bottom: 1px solid #555; width: 100%; padding-bottom: 10px; }
        .choice-desc { font-size: 14px; text-align: center; color: #ccc; flex: 1; }
        .choice-bonus { font-size: 12px; color: var(--accent-yellow); margin-top: 10px; }

        /* スロット選択画面 */
        #slot-select-container { display: none; flex-direction: column; align-items: center; width: 100%; }
        .slot-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 20px;
        }
        .slot-btn {
            background: #eee;
            color: #222;
            border: 2px solid #999;
            border-radius: 6px;
            padding: 10px;
            width: 350px;
            display: flex;
            align-items: center;
            cursor: pointer;
            transition: 0.2s;
            position: relative;
        }
        .slot-btn:hover { background: #fff; border-color: var(--accent-green); }
        .slot-btn .dice { transform: scale(0.6); margin-right: 10px; border: 1px solid #ccc; }
        .slot-info { display: flex; flex-direction: column; }
        .slot-preview { position: absolute; right: 10px; font-weight: bold; color: var(--accent-red); font-size: 18px; }

        /* --- タイトル画面 --- */
        #title-screen {
            display: flex; /* 初期表示 */
            z-index: 200;
            background: rgba(0,0,0,0.9);
        }
        
        .game-title {
            font-size: 72px;
            color: #e74c3c;
            text-shadow: 0 0 20px #c0392b;
            margin-bottom: 20px;
            font-family: 'Segoe UI', sans-serif;
            font-weight: 900;
            letter-spacing: 5px;
        }
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 30px;
        }
        .menu-btn {
            padding: 15px 60px;
            font-size: 24px;
            background: #222;
            color: white;
            border: 2px solid #555;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
            font-family: monospace;
        }
        .menu-btn:hover {
            background: #333;
            border-color: #2ecc71;
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(46, 204, 113, 0.4);
        }
        .credit-display {
            font-size: 20px;
            color: #f1c40f;
            font-family: monospace;
            border: 1px solid #f1c40f;
            padding: 10px 20px;
            border-radius: 30px;
            background: rgba(241, 196, 15, 0.1);
        }
        
        /* ゲームオーバー画面のボタン用 */
        .restart-btn {
            margin-top: 20px;
            padding: 10px 30px;
            font-size: 18px;
            background: transparent;
            color: #fff;
            border: 1px solid #fff;
            cursor: pointer;
        }
        .restart-btn:hover { background: #fff; color: #000; }

        /* --- ショップ画面 --- */
        /* --- ショップ画面 --- */
        #shop-screen {
            display: none;
            flex-direction: column;
            align-items: center;
            /* ★変更: 上下中央揃えを解除し、上詰めにすることでスクロール切れを防ぐ */
            justify-content: flex-start; 
            background: rgba(10, 10, 20, 0.95);
            z-index: 210;
            overflow-y: auto;
            /* 上下の余白を確保 */
            padding: 60px 40px; 
            box-sizing: border-box;
        }
        .shop-header {
            width: 100%;
            max-width: 900px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            border-bottom: 2px solid #555;
            padding-bottom: 20px;
        }
        .shop-title { font-size: 48px; font-weight: bold; color: #f1c40f; }
        .shop-credits { font-size: 24px; color: #fff; font-family: monospace; }
        
        .shop-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            width: 100%;
            max-width: 900px;
        }
        .shop-card {
            background: #222;
            border: 2px solid #444;
            border-radius: 8px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .shop-card-header { display: flex; justify-content: space-between; align-items: baseline; }
        .shop-item-name { font-size: 20px; font-weight: bold; color: var(--accent-green); }
        .shop-item-level { font-size: 14px; color: #aaa; }
        .shop-item-desc { font-size: 14px; color: #ccc; flex: 1; }
        .shop-buy-btn {
            padding: 10px;
            background: var(--accent-blue);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .shop-buy-btn:hover { background: #2980b9; }
        .shop-buy-btn:disabled { background: #555; color: #888; cursor: not-allowed; }
        .shop-cost { font-family: monospace; }
        
        .back-btn {
            margin-top: 30px;
            padding: 10px 40px;
            font-size: 20px;
            background: transparent;
            border: 2px solid #fff;
            color: #fff;
            cursor: pointer;
        }
        .back-btn:hover { background: #fff; color: #000; }

    </style>
</head>
<body>

<div id="game-container">
    <div id="top-bar">
        <div id="dice-container">
            <div class="dice face-1" id="dice-0"><div class="pip"></div></div>
        </div>

        <div class="status-group">
            <div class="status-header-row">
                <div class="status-label">LEVEL <span id="level-display" style="color:var(--text-color); font-size:1.2em">1</span></div>
                <div class="status-value" id="xp-text">0 / 50</div>
            </div>
            <div class="bar-bg"><div id="level-bar-fill"></div></div>
        </div>

        <div class="status-group">
            <div class="status-header-row">
                <div class="status-value" id="wave-timer-text" style="color: #ccc;">20.00sec.</div>
                <div class="status-label" style="text-align: right;">WAVE <span id="wave-display" style="color:var(--text-color); font-size:1.2em">1</span></div>
            </div>
            <div class="bar-bg"><div id="wave-bar-fill"></div></div>
        </div>
    </div>

    <div id="left-sidebar">
        <div id="skill-list-container">
            </div>
        <div id="hp-container">
            <div class="hp-header">
                <span>PLAYER HP</span>
                <span id="hp-text">100/100</span>
            </div>
            <div class="hp-bar-bg"><div id="hp-bar-fill"></div></div>
        </div>
    </div>

    <div id="game-viewport-wrapper">
        <canvas id="gameCanvas"></canvas>
        
        <div id="title-screen" class="overlay">
            <div class="game-title">DICE SURVIVORS</div>
            <div class="menu-buttons">
                <button id="btn-start" class="menu-btn" onclick="startGame()">GAME START</button>
                <button id="btn-shop" class="menu-btn" onclick="openShop()">SHOP</button>
            </div>
            <div class="credit-display">CREDITS: <span id="title-credits">0</span></div>
        </div>

        <div id="shop-screen" class="overlay">
            <div class="shop-header">
                <div class="shop-title">SHOP</div>
                <div class="shop-credits">CREDITS: <span id="shop-credits-display">0</span></div>
            </div>
            <div class="shop-grid" id="shop-container">
                </div>
            <div class="shop-grid" id="shop-container"></div>
            
            <button class="menu-btn" style="margin-top: 20px; background:#c0392b; border-color:#e74c3c; font-size:18px;" onclick="refundUpgrades()">
                RESET & REFUND ALL
            </button>

            <button class="back-btn" onclick="closeShop()">BACK TO TITLE</button>
        </div>

        <div id="pause-screen" class="overlay">
            <h1>PAUSED</h1>
            <p>Press Esc to Resume</p>
            <button class="restart-btn" onclick="backToTitle()">TITLE</button>
        </div>

        <div id="game-over-screen" class="overlay">
            <h1>GAME OVER</h1>
            <div style="margin-bottom: 20px; text-align: center;">
                <div style="font-size: 30px; color: #fff; font-weight: bold;">
                    SCORE: <span id="go-score">0</span>
                </div>
                <div style="font-size: 18px; color: #aaa;">
                    HIGH SCORE: <span id="go-high-score">0</span>
                </div>
                <div style="font-size: 14px; color: #f1c40f; margin-top: 5px;">
                    +<span id="go-credits">0</span> CREDITS
                </div>
            </div>
            <button class="restart-btn" onclick="backToTitle()">TITLE</button>
        </div>

        <div id="level-up-screen" class="overlay" style="display:none;">
            <div class="level-up-container">
                <div class="level-up-title">LEVEL UP!</div>
                
                <div id="weapon-select-container">
                    <div class="level-up-instruction">新しい武器を選んでください</div>
                    <div class="card-container" id="choice-cards-area"></div>
                </div>

                <div id="slot-select-container">
                    <div class="level-up-instruction">書き換える出目を選んでください</div>
                    <div class="level-up-instruction" style="font-size:14px; color:#aaa;">(同じ武器ならLv+2 / 違う武器ならLv+1)</div>
                    <div class="slot-grid" id="slot-buttons-area"></div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    // --- 定数・設定 ---
    const GAME_WIDTH = 987;
    const GAME_HEIGHT = 577;
    const DICE_ROLL_INTERVAL = 3000;
    const WAVE_INTERVAL = 15000; // ★変更: 20000 -> 15000 (15秒)
    const PLAYER_SPEED = 4;

    // 武器定義
    const WEAPON_TYPES = {
        missile: {
            id: 'missile',
            name: 'ミサイル',
            color: '#e74c3c',
            desc: '最も近い敵を追尾し爆発する弾を発射',
            effectDesc: '弾数が増加'
        },
        machinegun: {
            id: 'machinegun',
            name: 'マシンガン',
            color: '#f1c40f',
            desc: '最も近い敵へ高速で直進する弾を連射',
            effectDesc: '弾数が大きく増加'
        },
        shockwave: {
            id: 'shockwave',
            name: 'ショックウェーブ',
            color: '#3498db',
            desc: '自機を中心に敵を弾き飛ばす衝撃波を発生',
            effectDesc: '範囲が拡大'
        },
        drone: {
            id: 'drone',
            name: 'ドローン',
            color: '#2ecc71',
            desc: '自機の周囲を回転しながら広がる弾を発射',
            effectDesc: '弾数が増加'
        },
        gravity: {
            id: 'gravity',
            name: 'グラビティエリア',
            color: '#9b59b6',
            desc: 'ランダムな位置に鈍足化と継続ダメージを与えるエリアを設置',
            effectDesc: '範囲と持続時間が増加'
        }
    };

    // --- ショップ・アップグレード設定 ---
    // --- ショップ・アップグレード設定 ---
    const UPGRADE_CONFIG = {
        atk: { id: 'atk', name: '攻撃力強化', desc: '全武器のダメージが10%増加します', maxLevel: 5, costs: [4000, 8000, 16000, 32000, 64000] },
        hp: { id: 'hp', name: '最大HP強化', desc: '最大HPが+20増加します', maxLevel: 5, costs: [1000, 2000, 4000, 8000, 16000] },
        regen: { id: 'regen', name: 'HP自動回復', desc: 'HPが毎秒 2 ずつ回復します', maxLevel: 5, costs: [4000, 8000, 16000, 32000, 64000] },
        dice: { id: 'dice', name: '初期ダイス増加', desc: 'ゲーム開始時のダイスが1つ増えます', maxLevel: 1, costs: [100000] },
        speed: { id: 'speed', name: 'ダイス加速', desc: 'ダイスロール間隔が10%短縮されます', maxLevel: 5, costs: [4000, 8000, 16000, 32000, 64000] },
        luck: { id: 'luck', name: 'ジェム増量', desc: 'ジェムのドロップ量(経験値・スコア)が20%増加します', maxLevel: 5, costs: [2000, 4000, 8000, 16000, 32000] },
        time: { id: 'time', name: 'WAVE短縮', desc: '次のWAVEまでの時間が1秒短縮されます', maxLevel: 5, costs: [1000, 2000, 4000, 8000, 16000] },
        curse: { id: 'curse', name: '敵数増加', desc: '敵の出現数が10%増加します(稼ぎ効率UP)', maxLevel: 5, costs: [1000, 2000, 4000, 8000, 16000] },
        
        // --- 新規追加分 ---
        pickup: { id: 'pickup', name: '回収範囲拡大', desc: 'アイテムの回収範囲が15%広がります', maxLevel: 5, costs: [4000, 8000, 16000, 32000, 64000] },
        missile_ex: { id: 'missile_ex', name: 'ミサイル強化', desc: 'ミサイルの爆発範囲が15%広がります', maxLevel: 5, costs: [4000, 8000, 16000, 32000, 64000] },
        mg_pierce: { id: 'mg_pierce', name: 'マシンガン強化', desc: 'マシンガンの貫通数が+1されます', maxLevel: 5, costs: [4000, 8000, 16000, 32000, 64000] },
        shock_up: { id: 'shock_up', name: '衝撃波強化', desc: 'ショックウェーブの発動回数が+1されます', maxLevel: 5, costs: [4000, 8000, 16000, 32000, 64000] },
        drone_up: { id: 'drone_up', name: 'ドローン強化', desc: 'ドローンの発射数が+3されます', maxLevel: 5, costs: [4000, 8000, 16000, 32000, 64000] },
        grav_up: { id: 'grav_up', name: '重力エリア強化', desc: 'グラビティエリアの減速効果が強化されます', maxLevel: 5, costs: [4000, 8000, 16000, 32000, 64000] }
    };

    // アップグレードの保存データ読み込み
    let upgradeLevels = JSON.parse(localStorage.getItem('diceSurvivors_upgrades')) || {};
    
    // 全キーを数値型で初期化
    Object.keys(UPGRADE_CONFIG).forEach(key => {
        upgradeLevels[key] = Number(upgradeLevels[key]) || 0;
    });
    
    // 強制的に数値型に変換しておく (NaN防止)
    upgradeLevels.atk = Number(upgradeLevels.atk) || 0;
    upgradeLevels.hp = Number(upgradeLevels.hp) || 0;
    upgradeLevels.regen = Number(upgradeLevels.regen) || 0;
    upgradeLevels.dice = Number(upgradeLevels.dice) || 0;
    upgradeLevels.speed = Number(upgradeLevels.speed) || 0;
    upgradeLevels.luck = Number(upgradeLevels.luck) || 0;
    upgradeLevels.time = Number(upgradeLevels.time) || 0;
    upgradeLevels.curse = Number(upgradeLevels.curse) || 0;

    // 初期ダイススロット状態 (出目1~6)
    // 最初はすべてミサイル

    let diceSlots = [
        { type: 'missile', level: 1 }, // Face 1
        { type: 'missile', level: 2 }, // Face 2
        { type: 'missile', level: 3 }, // Face 3
        { type: 'missile', level: 4 }, // Face 4
        { type: 'missile', level: 5 }, // Face 5
        { type: 'missile', level: 6 }  // Face 6
    ];
    
    // --- ゲームステート ---
    const canvas = document.getElementById('gameCanvas');
    canvas.width = GAME_WIDTH;
    canvas.height = GAME_HEIGHT;
    const ctx = canvas.getContext('2d');
    let animationFrameId; // 追加: アニメーション停止用
    let isGameRunning = false; // 追加: ゲーム実行中フラグ

    let isPaused = false;
    let isGameOver = false;
    let isLevelUp = false;
    let lastTime = 0;
    
    // ★追加: スコアとセーブデータ管理
    let score = 0; // 今回のスコア (総獲得経験値)
    // ローカルストレージから読み込み (なければ0)
    let highScore = parseInt(localStorage.getItem('diceSurvivors_highScore')) || 0;
    let totalCredits = parseInt(localStorage.getItem('diceSurvivors_credits')) || 0;

    const keys = { w:false, a:false, s:false, d:false };
    // ... (以下既存コード)

    const player = { 
        x: GAME_WIDTH/2, y: GAME_HEIGHT/2, 
        size: 8, color: '#00ffff',
        hp: 100, maxHp: 100
    };

    let enemies = [];
    let projectiles = []; 
    let particles = [];
    let jewels = [];
    let diceDrops = []; // ★追加: ダイスドロップアイテム管理用
    let areaEffects = [];

    // 変数定義エリアに追加
    let enemyProjectiles = []; // 敵の弾丸管理用

    // クラス定義エリアに追加（Enemyクラスの前あたり）
    class EnemyProjectile {
        constructor(x, y, vx, vy) {
            this.x = x;
            this.y = y;
            this.vx = vx;
            this.vy = vy;
            this.size = 6;
            this.color = '#ff00ff';
            this.life = 200; // 寿命
        }

        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.life--;
        }

        draw() {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    let level = 1;
    let currentXp = 0;
    let nextLevelXp = 50;
    let wave = 1;
    
    let diceTimer = 0;
    let waveTimer = 0;
    let selectedNewWeaponId = null; // Level Up Temporary State

    

    // DOM Elements
    const domLevel = document.getElementById('level-display');
    const domLevelBar = document.getElementById('level-bar-fill');
    const domXpText = document.getElementById('xp-text');
    const domWave = document.getElementById('wave-display');
    const domWaveBar = document.getElementById('wave-bar-fill');
    const domWaveTimerText = document.getElementById('wave-timer-text');
    let domDiceDivs = Array.from(document.querySelectorAll('#dice-container .dice')); // letに変更    
    const domHpText = document.getElementById('hp-text');
    const domHpBar = document.getElementById('hp-bar-fill');
    const domSkillList = document.getElementById('skill-list-container');
    
    // Screens
    const screenPause = document.getElementById('pause-screen');
    const screenGameOver = document.getElementById('game-over-screen');
    const screenLevelUp = document.getElementById('level-up-screen');
    const containerWeaponSelect = document.getElementById('weapon-select-container');
    const containerSlotSelect = document.getElementById('slot-select-container');
    const areaChoiceCards = document.getElementById('choice-cards-area');
    const areaSlotButtons = document.getElementById('slot-buttons-area');

    // --- 初期化 ---
    function initUI() {
        updateSkillList();
        updateHpUI();
        updateXpUI();
    }

    

    function setDiceFace(element, faceNum) {
        element.className = `dice face-${faceNum}`;
        if(element.classList.contains('rolling')) element.classList.add('rolling');
        element.innerHTML = '';
        const pipCount = Math.max(1, Math.min(6, faceNum));
        for(let i=0; i<pipCount; i++) {
            const pip = document.createElement('div');
            pip.className = 'pip';
            element.appendChild(pip);
        }
    }

    // --- 入力系 ---
    window.addEventListener('keydown', e => {
        if(e.key === 'Escape' && !isGameOver && !isLevelUp) togglePause();
        if(!isPaused && !isGameOver && !isLevelUp) {
            if(e.key === 'w' || e.key === 'W') keys.w = true;
            if(e.key === 'a' || e.key === 'A') keys.a = true;
            if(e.key === 's' || e.key === 'S') keys.s = true;
            if(e.key === 'd' || e.key === 'D') keys.d = true;
        }
    });
    window.addEventListener('keyup', e => {
        if(e.key === 'w' || e.key === 'W') keys.w = false;
        if(e.key === 'a' || e.key === 'A') keys.a = false;
        if(e.key === 's' || e.key === 'S') keys.s = false;
        if(e.key === 'd' || e.key === 'D') keys.d = false;
    });

    function togglePause() {
        isPaused = !isPaused;
        screenPause.style.display = isPaused ? 'flex' : 'none';
        if(!isPaused) {
            lastTime = performance.now();
            // ここにあった requestAnimationFrame(gameLoop); を削除
        }
    }

    // --- レベルアップシステム ---

    function triggerLevelUp() {
        isLevelUp = true;
        screenLevelUp.style.display = 'flex';
        
        // Step 1 UI表示
        containerWeaponSelect.style.display = 'block';
        containerSlotSelect.style.display = 'none';

        // 3つの選択肢を生成 (重複なし)
        areaChoiceCards.innerHTML = '';
        const keys = Object.keys(WEAPON_TYPES);
        
        // ★変更: Fisher-Yates shuffle でランダムに並び替え
        for (let i = keys.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [keys[i], keys[j]] = [keys[j], keys[i]];
        }

        // 先頭3つを取得
        const selectedKeys = keys.slice(0, 3);
        const choices = selectedKeys.map(k => WEAPON_TYPES[k]);

        choices.forEach(weapon => {
            const card = document.createElement('div');
            card.className = 'choice-card';
            card.style.borderColor = weapon.color;
            card.innerHTML = `
                <div class="choice-name" style="color:${weapon.color}">${weapon.name}</div>
                <div class="choice-desc">${weapon.desc}</div>
                <div class="choice-bonus">${weapon.effectDesc}</div>
            `;
            card.onclick = () => selectLevelUpWeapon(weapon.id);
            areaChoiceCards.appendChild(card);
        });
    }

    function selectLevelUpWeapon(weaponId) {
        selectedNewWeaponId = weaponId;
        
        // Step 2 UIへ遷移
        containerWeaponSelect.style.display = 'none';
        containerSlotSelect.style.display = 'flex';

        // スロット選択ボタン生成
        areaSlotButtons.innerHTML = '';
        diceSlots.forEach((slot, index) => {
            const faceNum = index + 1;
            const isSame = slot.type === selectedNewWeaponId;
            const nextLevel = isSame ? slot.level + 2 : slot.level + 1; // 仕様：同じなら+2, 違うなら+1 (ここではLv1からスタートではなく、今のレベルを引き継ぐ挙動とする。問題文の「入れ替えた出目のレベルが1上がる」を「現在のそのスロットのレベル+1」と解釈)
            // ※もし「違う武器に入れ替えたらLv1になる」という解釈なら変更が必要ですが、「入れ替えた出目のレベルが１上がる」とあるので、既存Lv+1とします。

            const btn = document.createElement('div');
            btn.className = 'slot-btn';
            btn.style.borderColor = isSame ? WEAPON_TYPES[slot.type].color : '#999';
            
            // ダイスアイコン生成
            const diceDiv = document.createElement('div');
            setDiceFace(diceDiv, faceNum);
            
            btn.appendChild(diceDiv);
            btn.innerHTML += `
                <div class="slot-info">
                    <div style="font-weight:bold;">出目 ${faceNum}</div>
                    <div style="font-size:12px; color:#555;">現在: ${WEAPON_TYPES[slot.type].name} Lv.${slot.level}</div>
                </div>
                <div class="slot-preview" style="color:${isSame ? '#2ecc71' : '#e74c3c'}">
                    Lv.${nextLevel}
                </div>
            `;
            btn.onclick = () => applyLevelUp(index, nextLevel);
            areaSlotButtons.appendChild(btn);
        });
    }

    function applyLevelUp(slotIndex, nextLevel) {
        // データ更新
        diceSlots[slotIndex] = {
            type: selectedNewWeaponId,
            level: nextLevel
        };
        updateSkillList();

        // 復帰処理
        isLevelUp = false;
        screenLevelUp.style.display = 'none';
        // ここにあったループ再開処理を削除
    }

    // --- ゲームオブジェクト ---

    class Enemy {
        constructor(x, y, type = 'normal', isBoss = false, noGem = false) {
            this.x = x;
            this.y = y;
            this.type = type;
            this.isBoss = isBoss;
            this.noGem = noGem;
            
            this.timer = 0; 
            
            // --- 射撃型用: バースト管理 ---
            this.burstTimer = 0;
            this.isBursting = false;
            this.burstCount = 0;
            
            // ステータス設定
            let hpMult = 1;
            let speedMult = 1;
            let sizeBase = 12;
            let color = '#ff4444';

            if (this.type === 'fortress') {
                hpMult = 2.0; speedMult = 0.6; sizeBase = 20; color = '#7f8c8d';
            } else if (this.type === 'rusher') {
                hpMult = 0.5; speedMult = 0.8; sizeBase = 10; color = '#e67e22';
                this.rushAngle = Math.random() * Math.PI * 2;
            } else if (this.type === 'shooter') {
                hpMult = 0.9; speedMult = 0.8; sizeBase = 14; color = '#2980b9';
            } else if (this.type === 'summoner') {
                hpMult = 2.0; speedMult = 0.5; sizeBase = 18; color = '#16a085';
            } else if (this.type === 'teleporter') {
                hpMult = 1.5; speedMult = 0.6; sizeBase = 16; color = '#8e44ad';
                this.state = 0; 
            }

            // ★変更: Wave55以降のHPインフレ計算
            // 基本HP計算
            let baseHp = 10 + (wave * 2);
            
            // Wave55を超えていたら、1WaveごとにHP倍率を上げる
            if (wave > 55) {
                // 例: Wave65なら (65-55)*0.1 = 1.0 -> 基本HPの2倍
                // 例: Wave75なら (75-55)*0.1 = 2.0 -> 基本HPの3倍
                const inflationMult = 1 + (wave - 55) * 0.1;
                baseHp *= inflationMult;
            }

            if (this.isBoss) {
                this.size = sizeBase * 3;
                this.hp = (300 + (wave * 60)) * hpMult;
                
                // ボスも同様にインフレさせる
                if (wave > 55) {
                    const inflationMult = 1 + (wave - 55) * 0.1;
                    this.hp *= inflationMult;
                }
                
                this.speed = 0.5 * speedMult;
                this.color = color;
            } else {
                this.size = sizeBase;
                this.hp = baseHp * hpMult;
                this.speed = (1.0 + (Math.random() * 0.25)) * speedMult;
                this.color = color;
            }
            
            this.maxHp = this.hp; 
            this.baseSpeed = this.speed;
            this.slowTimer = 0;
            this.dps = this.isBoss ? 50 : (25 + (wave * 2));
        }

        update(dt) {
            // ★変更: 減速倍率(speedFactor)の計算
            let speedFactor = 1.0;
            
            if(this.slowTimer > 0) {
                // グラビティ強化Lvを取得
                const gravLv = upgradeLevels.grav_up || 0;
                // Lv0で0.6 (60%速度=40%減速)
                // Lv5で0.1 (10%速度=90%減速)
                // 1レベルごとに -0.1
                speedFactor = Math.max(0.1, 0.6 - (gravLv * 0.1));
                
                this.slowTimer -= dt;
            }

            // 現在の移動速度に倍率を適用
            let currentSpeed = this.speed * speedFactor;

            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const dist = Math.hypot(dx, dy);
            
            this.timer++;

            // --- 行動ロジック ---
            if (this.type === 'teleporter') {
                if (this.state === 0) {
                    if (dist > 0) {
                        this.x += (dx / dist) * currentSpeed;
                        this.y += (dy / dist) * currentSpeed;
                    }
                    if (this.timer > 200) { this.state = 1; this.timer = 0; }
                } else if (this.state === 1) {
                    if (this.timer > 60) {
                        this.x = Math.random() * (GAME_WIDTH - 100) + 50;
                        this.y = Math.random() * (GAME_HEIGHT - 100) + 50;
                        this.state = 2; this.timer = 0;
                        for(let i=0; i<8; i++) {
                            const ang = (Math.PI * 2 / 8) * i;
                            const spd = 1.5;
                            enemyProjectiles.push(new EnemyProjectile(this.x, this.y, Math.cos(ang)*spd, Math.sin(ang)*spd));
                        }
                    }
                } else if (this.state === 2) {
                    if (this.timer > 30) { this.state = 0; this.timer = 0; }
                }

            } else {
                // 移動計算
                let moveX = 0, moveY = 0;

                if (this.type === 'rusher') {
                    const angle = Math.atan2(dy, dx);
                    
                    // ★修正: 蛇行のアニメーション進行もスローにする
                    this.rushAngle += 0.04 * speedFactor; 
                    
                    // ★修正: 横振れの強さにもスロー倍率を適用する
                    const curveStrength = 4.5 * speedFactor;
                    
                    moveX = Math.cos(angle) * currentSpeed + Math.cos(this.rushAngle + angle + Math.PI/2) * curveStrength;
                    moveY = Math.sin(angle) * currentSpeed + Math.sin(this.rushAngle + angle + Math.PI/2) * curveStrength;

                } else if (this.type === 'shooter') {
                    const range = 300;
                    if (dist > range) {
                        moveX = (dx / dist) * currentSpeed;
                        moveY = (dy / dist) * currentSpeed;
                    }

                    // バースト制御
                    if (!this.isBursting) {
                        const cooldown = this.isBoss ? 200 : 400;
                        if (this.timer > cooldown && dist < 600) {
                            this.isBursting = true;
                            this.burstTimer = 0;
                            this.burstCount = 0;
                            this.timer = 0;
                        }
                    } else {
                        this.burstTimer++;
                        const fireRate = this.isBoss ? 8 : 25;
                        const shotsPerBurst = this.isBoss ? 8 : 4;

                        if (this.burstTimer >= fireRate) {
                            this.burstTimer = 0;
                            this.burstCount++;

                            const shotSpeed = 2.5;
                            const baseAngle = Math.atan2(dy, dx);

                            if (this.isBoss) {
                                const angles = [baseAngle - 0.2, baseAngle, baseAngle + 0.2];
                                angles.forEach(a => {
                                    enemyProjectiles.push(new EnemyProjectile(
                                        this.x, this.y, Math.cos(a)*shotSpeed, Math.sin(a)*shotSpeed
                                    ));
                                });
                            } else {
                                enemyProjectiles.push(new EnemyProjectile(
                                    this.x, this.y, Math.cos(baseAngle)*shotSpeed, Math.sin(baseAngle)*shotSpeed
                                ));
                            }

                            if (this.burstCount >= shotsPerBurst) {
                                this.isBursting = false;
                                this.timer = 0;
                            }
                        }
                    }

                } else if (this.type === 'summoner') {
                    moveX = (dx / dist) * currentSpeed;
                    moveY = (dy / dist) * currentSpeed;
                    
                    const summonInterval = 300;
                    if (this.timer % summonInterval === 0) {
                        const summonCount = this.isBoss ? 8 : 3;
                        for(let i=0; i<summonCount; i++) {
                            const offsetX = (Math.random() - 0.5) * 60;
                            const offsetY = (Math.random() - 0.5) * 60;
                            const minion = new Enemy(this.x + offsetX, this.y + offsetY, 'normal', false, true);
                            minion.hp = 10;
                            enemies.push(minion);
                        }
                    }
                } else {
                    moveX = (dx / dist) * currentSpeed;
                    moveY = (dy / dist) * currentSpeed;
                }

                this.x += moveX;
                this.y += moveY;
            }
        }

        draw() {
            // (前回の描画コードと同じ)
            if (this.type === 'teleporter' && this.state === 1) {
                if (Math.floor(this.timer / 5) % 2 === 0) return;
            }

            ctx.fillStyle = this.slowTimer > 0 ? '#999' : this.color;
            ctx.beginPath();
            
            if (this.type === 'fortress') {
                ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
            } else if (this.type === 'rusher') {
                ctx.moveTo(this.x + Math.cos(this.rushAngle)*this.size, this.y + Math.sin(this.rushAngle)*this.size);
                ctx.lineTo(this.x + Math.cos(this.rushAngle + 2.6)*this.size, this.y + Math.sin(this.rushAngle + 2.6)*this.size);
                ctx.lineTo(this.x + Math.cos(this.rushAngle - 2.6)*this.size, this.y + Math.sin(this.rushAngle - 2.6)*this.size);
                ctx.fill();
            } else {
                ctx.arc(this.x, this.y, this.size/2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            if (this.isBoss) {
                this.drawBossUI();
            } else {
                ctx.fillStyle = 'black';
                ctx.fillRect(this.x - 2, this.y - 2, 4, 4);
            }
        }

        drawBossUI() {
            const barWidth = 80;
            const barHeight = 8;
            const barX = this.x - barWidth / 2;
            const barY = this.y - this.size / 2 - 20;

            ctx.fillStyle = '#222';
            ctx.fillRect(barX, barY, barWidth, barHeight);
            const ratio = Math.max(0, this.hp / this.maxHp);
            ctx.fillStyle = '#e74c3c';
            ctx.fillRect(barX, barY, barWidth * ratio, barHeight);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.strokeRect(barX, barY, barWidth, barHeight);
        }
    }

    // ★追加: ダイスドロップアイテム
    class DiceDrop {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.size = 20;
            this.phase = 0;
            this.magnetized = false;
        }
        update() {
            this.phase += 0.1;
            const floatY = Math.sin(this.phase) * 5; 
            
            // ★修正: ここでプレイヤーとの距離を計算する
            const dx = player.x - this.x;
            const dy = player.y - (this.y + floatY); // 浮遊演出を考慮した位置との距離
            const dist = Math.hypot(dx, dy);

            // 回収範囲アップグレード適用
            const pickupLv = upgradeLevels.pickup || 0;
            const magnetRange = 150 * (1 + pickupLv * 0.15);

            if(dist < magnetRange) this.magnetized = true;
            
            if(this.magnetized) {
                const speed = 8;
                this.x += (dx / dist) * speed;
                this.y += (dy / dist) * speed;
            }

            // 画面外に出ないように座標を制限
            const margin = this.size; 
            if(this.x < margin) this.x = margin;
            if(this.x > GAME_WIDTH - margin) this.x = GAME_WIDTH - margin;
            if(this.y < margin) this.y = margin;
            if(this.y > GAME_HEIGHT - margin) this.y = GAME_HEIGHT - margin;
        }

        draw() {
            ctx.save();
            ctx.translate(this.x, this.y + Math.sin(this.phase)*5);
            ctx.fillStyle = '#fff';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.rect(-10, -10, 20, 20);
            ctx.fill();
            ctx.stroke();
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.arc(0, 0, 4, 0, Math.PI*2);
            ctx.fill();
            ctx.restore();
        }
    }

    // 汎用プロジェクタイルクラス
    // 汎用プロジェクタイルクラス
    // 汎用プロジェクタイルクラス
    // 汎用プロジェクタイルクラス
    class Projectile {
        constructor(x, y, type, level, target) {
            this.x = x;
            this.y = y;
            this.type = type;
            this.level = level;
            this.target = target;
            this.life = 200;
            this.trail = [];
            this.angle = 0; // for Drone
            this.orbitDist = 0; // for Drone

            // Type specific init
            if(type === 'missile') {
                this.speed = 7;
                this.size = 3;
                this.color = '#e74c3c';
                const a = Math.random() * Math.PI * 2;
                this.vx = Math.cos(a) * 3; 
                this.vy = Math.sin(a) * 3;
            } else if(type === 'machinegun') {
                this.speed = 12;
                this.size = 2;
                this.color = '#f1c40f';
                // ★追加: 貫通管理用（当たった敵を記録）
                this.hitEnemies = []; 
                
                if(target) {
                    const dx = target.x - x;
                    const dy = target.y - y;
                    const angle = Math.atan2(dy, dx);
                    const spread = (Math.random() - 0.5) * 0.2;
                    this.vx = Math.cos(angle + spread) * this.speed;
                    this.vy = Math.sin(angle + spread) * this.speed;
                } else {
                    const a = Math.random() * Math.PI * 2;
                    this.vx = Math.cos(a) * this.speed;
                    this.vy = Math.sin(a) * this.speed;
                }
            } else if(type === 'drone') {
                this.speed = 0.08; 
                this.size = 4;
                this.color = '#2ecc71';
                this.angle = Math.random() * Math.PI * 2;
                this.orbitDist = 55; 
                this.life = 300;
                this.hitCooldowns = [];
            }
        }

        update() {
            this.life--;
            
            if(this.type === 'drone') {
                for(let k = this.hitCooldowns.length - 1; k >= 0; k--) {
                    this.hitCooldowns[k].timer--;
                    if(this.hitCooldowns[k].timer <= 0) {
                        this.hitCooldowns.splice(k, 1);
                    }
                }
            }

            if(this.type === 'missile') {
                this.trail.push({x:this.x, y:this.y});
                if(this.trail.length > 5) this.trail.shift();

                if (this.target && enemies.includes(this.target)) {
                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    const angle = Math.atan2(dy, dx);
                    this.vx = this.vx * 0.9 + Math.cos(angle) * 1.0;
                    this.vy = this.vy * 0.9 + Math.sin(angle) * 1.0;
                } else {
                    this.target = getClosestEnemy(this.x, this.y);
                }
                const vel = Math.hypot(this.vx, this.vy);
                if(vel > this.speed) {
                    this.vx = (this.vx / vel) * this.speed;
                    this.vy = (this.vy / vel) * this.speed;
                }
                this.x += this.vx;
                this.y += this.vy;

            } else if(this.type === 'machinegun') {
                this.x += this.vx;
                this.y += this.vy;

            } else if(this.type === 'drone') {
                this.angle += this.speed;
                this.orbitDist += 0.15; 
                this.x = player.x + Math.cos(this.angle) * this.orbitDist;
                this.y = player.y + Math.sin(this.angle) * this.orbitDist;
                
                this.trail.push({x:this.x, y:this.y});
                if(this.trail.length > 10) this.trail.shift();
            }
        }

        draw() {
            if(this.trail.length > 0) {
                ctx.strokeStyle = this.color;
                ctx.globalAlpha = 0.5;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.trail[0].x, this.trail[0].y);
                for(let t of this.trail) ctx.lineTo(t.x, t.y);
                ctx.stroke();
                ctx.globalAlpha = 1.0;
            }

            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    class AreaEffect {
        constructor(x, y, type, level) {
            this.x = x;
            this.y = y;
            this.type = type;
            this.level = level;
            this.timer = 0;
            
            if(type === 'shockwave') {
                this.maxRadius = 50 + level * 15;
                this.duration = 20; 
                this.currentRadius = 0;
            } else if(type === 'gravity') {
                // ★変更: 範囲と持続時間を減少 (ナーフ)
                // 半径: 60->50, 増加率ダウン
                // 持続: 180->120 (2秒)
                this.maxRadius = 90 + level * 5; 
                this.duration = 580 + level * 20; 
                this.currentRadius = this.maxRadius;
            }
        }
        
        update(dt) {
            this.timer++;
            
            if(this.type === 'shockwave') {
                this.currentRadius = (this.timer / this.duration) * this.maxRadius;
                
                // --- 敵への干渉 (既存処理) ---
                enemies.forEach(e => {
                    const dx = e.x - this.x;
                    const dy = e.y - this.y;
                    const dist = Math.hypot(dx, dy);
                    if(dist < this.currentRadius && dist > this.currentRadius - 10) {
                        const pushPower = 10;
                        e.x += (dx/dist) * pushPower;
                        e.y += (dy/dist) * pushPower;

                        const baseDmg = this.level;
                        e.hp -= getDamage(baseDmg); 
                        
                        if(e.hp <= 0 && !e.dead) {
                             e.dead = true; 
                        }
                    }
                });

                // --- ★追加: 敵弾の消去 (防御機能) ---
                for(let i = enemyProjectiles.length - 1; i >= 0; i--) {
                    const ep = enemyProjectiles[i];
                    const dist = Math.hypot(ep.x - this.x, ep.y - this.y);
                    
                    // 衝撃波の内側に入った弾を消す
                    if(dist < this.currentRadius) {
                        // 消滅時に白い火花を散らす演出
                        particles.push(new Particle(ep.x, ep.y, '#ffffff', 3, 15));
                        
                        enemyProjectiles.splice(i, 1);
                    }
                }

            } else if(this.type === 'gravity') {
                enemies.forEach(e => {
                    const dist = Math.hypot(e.x - this.x, e.y - this.y);
                    if(dist < this.maxRadius) {
                        e.slowTimer = 100;
                        if(this.timer % 10 === 0) {
                            const baseDmg = 0.2 + (this.level * 0.1); 
                            e.hp -= getDamage(baseDmg); 
                            if(e.hp <= 0) e.dead = true;
                        }
                    }
                });
            }
        }

        draw() {
            if(this.type === 'shockwave') {
                ctx.strokeStyle = `rgba(52, 152, 219, ${1 - this.timer/this.duration})`;
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.currentRadius, 0, Math.PI * 2);
                ctx.stroke();
            } else if(this.type === 'gravity') {
                ctx.fillStyle = `rgba(155, 89, 182, 0.2)`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.maxRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = `rgba(155, 89, 182, 0.5)`;
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }
    }

    class Particle {
        constructor(x, y, color, speed, life) {
            this.x = x;
            this.y = y;
            this.color = color;
            this.life = life;
            this.maxLife = life;
            const angle = Math.random() * Math.PI * 2;
            const spd = Math.random() * speed;
            this.vx = Math.cos(angle) * spd;
            this.vy = Math.sin(angle) * spd;
            this.size = Math.random() * 3 + 1;
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.life--;
            this.vx *= 0.95;
            this.vy *= 0.95;
        }
        draw() {
            ctx.globalAlpha = this.life / this.maxLife;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }
    }

    class Jewel {
        constructor(x, y, xp) {
            this.x = x;
            this.y = y;
            this.xp = xp;
            
            // ★変更: 高価値ジェムの定義を追加し、巨大な数値をサポート
            if(this.xp >= 1000) { this.color = '#9b59b6'; this.size = 5; }     // 紫 (特大)
            else if(this.xp >= 300) { this.color = '#c0392b'; this.size = 4; } // 深紅 (大)
            else if(this.xp >= 100) { this.color = '#e74c3c'; this.size = 4; } // 赤
            else if(this.xp >= 50) { this.color = '#e67e22'; this.size = 3; }   // オレンジ
            else if(this.xp >= 25) { this.color = '#f39c12'; this.size = 3; }   // 黄
            else if(this.xp >= 10) { this.color = '#f1c40f'; this.size = 2; }   // 薄黄
            else if(this.xp >= 3) { this.color = '#2ecc71'; this.size = 2; }    // 緑
            else { this.color = '#3498db'; this.size = 2; }                     // 青

            this.magnetized = false;
            
            // 散らばる演出用の物理演算（変更なし）
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 4 + 2; 
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
            this.friction = 0.92; 
        }
        
        // ... (update, draw メソッドは変更なしのため省略)
        
        update() {
            // 吸い寄せ前は物理挙動で散らばる
            if (!this.magnetized) {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= this.friction;
                this.vy *= this.friction;
            }

            // ★修正: ここでプレイヤーとの距離を計算する
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const dist = Math.hypot(dx, dy);

            // 回収範囲アップグレード適用
            const pickupLv = upgradeLevels.pickup || 0;
            const magnetRange = 150 * (1 + pickupLv * 0.15);
            
            if(dist < magnetRange) this.magnetized = true;

            if(this.magnetized) {
                const speed = 12; 
                this.x += (dx / dist) * speed;
                this.y += (dy / dist) * speed;
            }

            // 画面外に出ないように座標を制限（クランプ）
            const margin = this.size + 2;
            if(this.x < margin) this.x = margin;
            if(this.x > GAME_WIDTH - margin) this.x = GAME_WIDTH - margin;
            if(this.y < margin) this.y = margin;
            if(this.y > GAME_HEIGHT - margin) this.y = GAME_HEIGHT - margin;
        }

        draw() {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.moveTo(this.x, this.y - this.size);
            ctx.lineTo(this.x + this.size, this.y);
            ctx.lineTo(this.x, this.y + this.size);
            ctx.lineTo(this.x - this.size, this.y);
            ctx.fill();
        }
    }

    // ★変更: 高額ジェムに自動両替してドロップ数を削減する関数
    function spawnGems(x, y, baseXp) {
        // ジェム増加アップグレード適用
        const luckLevel = upgradeLevels.luck || 0;
        let totalXp = Math.floor(baseXp * (1 + luckLevel * 0.2));

        // 通貨のように大きな単位を定義
        const denominations = [1000, 300, 100, 50, 25, 10, 3, 1];

        // 大きい単位から順に引き算していく
        denominations.forEach(val => {
            while(totalXp >= val) {
                // 重なりすぎないよう微妙に位置をずらす
                const offsetX = (Math.random() - 0.5) * 10;
                const offsetY = (Math.random() - 0.5) * 10;
                
                jewels.push(new Jewel(x + offsetX, y + offsetY, val));
                totalXp -= val;
            }
        });
    }

    // --- ヘルパー関数 ---

    function getClosestEnemy(x, y) {
        let nearest = null;
        let minDist = Infinity;
        for(let e of enemies) {
            const d = Math.hypot(e.x - x, e.y - y);
            if(d < minDist) {
                minDist = d;
                nearest = e;
            }
        }
        return nearest;
    }

    function spawnEnemyBatch() {
        // --- 雑魚敵の数計算 ---
        let count = 5 + wave * 4;
        
        // ★変更: Wave55以降、雑魚敵の増え方を加速させる
        if (wave > 55) {
            // 1Waveごとにさらに+2体追加 (合計+4体/Waveペース)
            count += (wave - 55) * 4;
        }

        // 敵増加呪い適用
        const curseLevel = upgradeLevels.curse || 0;
        count = Math.floor(count * (1 + curseLevel * 0.1));

        const margin = 40;
        
        // --- 雑魚敵のタイプ抽選リスト作成 ---
        let availableTypes = ['normal'];
        if (wave >= 5) availableTypes.push('fortress'); 
        if (wave >= 15) availableTypes.push('rusher');
        if (wave >= 25) availableTypes.push('shooter');
        if (wave >= 35) availableTypes.push('summoner');
        if (wave >= 45) availableTypes.push('teleporter');
        // ランダム選出用の全ボスリスト
        const allBossTypes = ['fortress', 'rusher', 'shooter', 'summoner', 'teleporter'];

        // --- ボス出現判定 ---
        // ★変更: Wave55以降の特殊ロジックを追加
        
        let bossSpawnCount = 0;

        if (wave >= 55) {
            // Wave55以降: 5Waveごとにボス出現
            if (wave % 5 === 0) {
                // 55:1体, 60:2体, 65:3体...
                bossSpawnCount = 1 + (wave - 55) / 5;
            }
        } else {
            // Wave54まで: 10Waveごとに1体 (既存ルール)
            if (wave % 10 === 0) {
                bossSpawnCount = 1;
            }
        }

        // ボス生成ループ
        for(let k=0; k < bossSpawnCount; k++) {
            let bossType = 'normal';

            if (wave >= 55) {
                // ランダムなボスを選択
                bossType = allBossTypes[Math.floor(Math.random() * allBossTypes.length)];
            } else {
                // 既存の固定ボス
                if (wave === 10) bossType = 'fortress';
                else if (wave === 20) bossType = 'rusher';
                else if (wave === 30) bossType = 'shooter';
                else if (wave === 40) bossType = 'summoner';
                else if (wave === 50) bossType = 'teleporter';
            }

            let ex = GAME_WIDTH / 2;
            // 複数出るときは少し位置をずらす
            let ey = -margin * 2 - (k * 100); 
            
            // 横にも少し散らす
            if (bossSpawnCount > 1) {
                ex += (Math.random() - 0.5) * 200;
            }

            enemies.push(new Enemy(ex, ey, bossType, true));
        }

        // --- 雑魚敵生成 ---
        for(let i=0; i<count; i++) {
            let ex, ey;
            const side = Math.floor(Math.random() * 4);
            if(side === 0) { ex = Math.random() * GAME_WIDTH; ey = -margin; } 
            else if(side === 1) { ex = Math.random() * GAME_WIDTH; ey = GAME_HEIGHT + margin; } 
            else if(side === 2) { ex = -margin; ey = Math.random() * GAME_HEIGHT; } 
            else { ex = GAME_WIDTH + margin; ey = Math.random() * GAME_HEIGHT; } 
            
            const type = availableTypes[Math.floor(Math.random() * availableTypes.length)];
            enemies.push(new Enemy(ex, ey, type, false));
        }
    }

    // ★追加: ダイス獲得処理
    function gainDice() {
        const container = document.getElementById('dice-container');
        const currentDiceCount = container.getElementsByClassName('dice').length;

        if (currentDiceCount < 5) {
            // 5個未満ならダイスを追加
            const newIndex = currentDiceCount;
            const newDice = document.createElement('div');
            // 初期表示用
            newDice.className = 'dice face-1'; 
            newDice.id = `dice-${newIndex}`;
            newDice.innerHTML = '<div class="pip"></div>';
            container.appendChild(newDice);
            
            // ダイスリストを更新（ここ重要）
            refreshDiceList();
        } else {
            // 5個あるなら全スキルのレベルを+2
            diceSlots.forEach(slot => {
                slot.level += 2;
            });
            updateSkillList(); // UI更新
            
            // 演出（レベルアップ画面のようなものを出すか、簡易的な通知）
            // ここでは簡易的にログ出力やエフェクト（本来は画面に文字を出すのが親切）
            createExplosion(player.x, player.y); // プレイヤーが光る的な演出代用
        }
    }

    // ★追加: DOM要素のリストを再取得する関数
    function refreshDiceList() {
        // domDiceDivs は const ではなく let に変更するか、配列の中身を入れ替える必要がある
        // 既存コードの domDiceDivs は Array.from(...) で生成されているため、
        // グローバル変数の定義を変更するほうが安全です。
        
        // ※注意: 下記の手順6で domDiceDivs を let に変更してください。
        domDiceDivs = Array.from(document.querySelectorAll('#dice-container .dice'));
    }

    function createExplosion(x, y) {
        for(let i=0; i<8; i++) particles.push(new Particle(x, y, '#ffaa00', 3, 20));
        for(let i=0; i<4; i++) particles.push(new Particle(x, y, '#ffffff', 2, 10));
    }

    // ★追加: ミサイル用の大きな爆発
    function createMissileExplosion(x, y) {
        // 赤く、大きく、数多く
        for(let i=0; i<16; i++) particles.push(new Particle(x, y, '#e74c3c', 6, 40)); 
        for(let i=0; i<8; i++) particles.push(new Particle(x, y, '#f39c12', 4, 30));
        for(let i=0; i<8; i++) particles.push(new Particle(x, y, '#ffffff', 2, 20));
    }

    // スキル一覧（左サイドバー）の表示更新
    function updateSkillList() {
        domSkillList.innerHTML = '';
        diceSlots.forEach((slot, index) => {
            const weapon = WEAPON_TYPES[slot.type];
            const card = document.createElement('div');
            card.className = 'skill-card';
            card.style.borderLeftColor = weapon.color;
            
            // ダイスアイコン
            const diceDiv = document.createElement('div');
            diceDiv.className = `dice face-${index + 1}`; // 出目はindex+1
            // ピップ（点）の生成
            const pipCount = index + 1;
            for(let i=0; i<pipCount; i++) {
                const pip = document.createElement('div');
                pip.className = 'pip';
                diceDiv.appendChild(pip);
            }
            
            card.appendChild(diceDiv);
            card.innerHTML += `
                <div class="skill-info">
                    <div class="skill-title">
                        <span style="color:${weapon.color}">${weapon.name}</span>
                        <span class="skill-level">Lv.${slot.level}</span>
                    </div>
                    <div class="skill-desc">${weapon.desc}</div>
                </div>
            `;
            domSkillList.appendChild(card);
        });
    }

    function updateHpUI() {
        const dispHp = player.hp.toFixed(1); 
        
        // ★変更: 回復スピードを表示に追加
        // 現在のレベル × 2 が秒間回復量
        const regenRate = (upgradeLevels.regen || 0) * 0.5;
        // 回復量がある場合だけ (+X/s) と表示
        const regenText = regenRate > 0 ? ` (+${regenRate}/s)` : '';
        
        domHpText.innerText = `${dispHp} / ${player.maxHp}${regenText}`;
        
        const ratio = (player.hp / player.maxHp) * 100;
        domHpBar.style.width = Math.max(0, ratio) + '%';
        if(ratio < 30) domHpBar.style.backgroundColor = '#e74c3c'; 
        else domHpBar.style.backgroundColor = '#2ecc71'; 
    }

    function updateXpUI() {
        domXpText.innerText = `${currentXp} / ${nextLevelXp}`;
        const p = (currentXp / nextLevelXp) * 100;
        domLevelBar.style.width = p + '%';
    }

    function updateDice(dt) {
        // 追加: 敵がいないときはタイマーを進めない
        if(enemies.length === 0) return;

        // ★変更: ダイス加速アップグレードの適用
        // Lvごとに10%短縮 (Lv5で50%短縮)
        const speedLevel = upgradeLevels.speed || 0;
        const reductionRatio = speedLevel * 0.1;
        const currentInterval = DICE_ROLL_INTERVAL * (1 - reductionRatio);

        diceTimer += dt;
        if(diceTimer >= currentInterval) {
            diceTimer = 0;
            rollDice();
        }
    }

    // 武器発射ロジック
    function fireWeapon(type, level) {
        if(type === 'missile') {
            const count = level * 2;
            const target = getClosestEnemy(player.x, player.y);
            if(target || enemies.length > 0) {
                for(let i=0; i<count; i++) {
                    setTimeout(() => projectiles.push(new Projectile(player.x, player.y, 'missile', level, target)), i*60);
                }
            }
        } else if(type === 'machinegun') {
            const count = level * 8; 
            if(enemies.length > 0) {
                for(let i=0; i<count; i++) {
                    setTimeout(() => {
                        const currentTarget = getClosestEnemy(player.x, player.y);
                        projectiles.push(new Projectile(player.x, player.y, 'machinegun', level, currentTarget));
                    }, i*30);
                }
            }
            
        } else if(type === 'shockwave') {
            // ★変更: レベル依存をやめ、ベース1回 + アップグレード回数に変更
            const bonusCount = upgradeLevels.shock_up || 0;
            const count = 1 + bonusCount;
            
            const interval = 350; 
            for(let i=0; i<count; i++) {
                setTimeout(() => {
                    if(!isGameOver) {
                        areaEffects.push(new AreaEffect(player.x, player.y, 'shockwave', level));
                    }
                }, i * interval);
            }

        } else if(type === 'drone') {
            // ★変更: 基本数(1+Lv) + アップグレード数(Lv*3)
            const bonus = (upgradeLevels.drone_up || 0) * 3;
            const count = 1 + level + bonus;
            
            for(let i=0; i<count; i++) {
                setTimeout(() => projectiles.push(new Projectile(player.x, player.y, 'drone', level, null)), i*100);
            }

        } else if(type === 'gravity') {
            const rx = Math.random() * (GAME_WIDTH - 100) + 50;
            const ry = Math.random() * (GAME_HEIGHT - 100) + 50;
            areaEffects.push(new AreaEffect(rx, ry, 'gravity', level));
        }
    }

    function rollDice() {
        domDiceDivs.forEach((div, index) => {
            div.classList.add('rolling');
            const spinInterval = setInterval(() => {
                const randomFace = Math.floor(Math.random() * 6) + 1;
                setDiceFace(div, randomFace);
                div.classList.add('rolling'); 
            }, 80);

            const stopDelay = 600 + (index * 150);
            setTimeout(() => {
                clearInterval(spinInterval);
                div.classList.remove('rolling');
                
                // 1~6の出目を決定
                const resultFace = Math.floor(Math.random() * 6) + 1;
                setDiceFace(div, resultFace);

                // 出目に対応するスロットの効果を発動 (index 0~5 = Face 1~6)
                // 結果が「3」なら、diceSlots[2] (Face 3の設定) を使う
                // ※ 仕様の再確認:
                // 「画面左上には最大で５つのダイスを置きます」
                // 「左側にある表に従って、出目の効果が一斉に発動します」
                // つまり、5個のダイスがそれぞれ 1~6 の値を出し、その値に対応する「表（スロット）」のスキルが発動する。
                // 例: ダイス1が[3]を出した -> Face 3 のスキル発動
                
                const slotIndex = resultFace - 1;
                const slotData = diceSlots[slotIndex];
                
                // 発動
                fireWeapon(slotData.type, slotData.level);

            }, stopDelay);
        });
    }

    function updateWave(dt) {
        waveTimer += dt;

        // ★変更: WAVE短縮アップグレード適用
        // Lvごとに1秒(1000ms)短縮
        const timeLevel = upgradeLevels.time || 0;
        const reductionMs = timeLevel * 1000;
        const currentWaveInterval = Math.max(5000, WAVE_INTERVAL - reductionMs); // 最低5秒は確保

        const ratio = 1 - (waveTimer / currentWaveInterval);
        domWaveBar.style.width = Math.max(0, ratio * 100) + '%';
        
        const remainingSec = Math.max(0, (currentWaveInterval - waveTimer) / 1000);
        domWaveTimerText.innerText = remainingSec.toFixed(2) + 'sec.';

        if(waveTimer >= currentWaveInterval) {
            waveTimer = 0;
            wave++;
            domWave.innerText = wave;
            spawnEnemyBatch();
        }
    }

    function gainXp(amount) {
        currentXp += amount;
        score += amount; // ★追加: スコア加算

        if(currentXp >= nextLevelXp) {
            currentXp -= nextLevelXp;
            level++;
            nextLevelXp = Math.floor(nextLevelXp * 1.3);
            domLevel.innerText = level;
            triggerLevelUp();
        }
        updateXpUI();
    }

    function resolveEnemyCollisions() {
        for (let i = 0; i < enemies.length; i++) {
            for (let j = i + 1; j < enemies.length; j++) {
                const e1 = enemies[i];
                const e2 = enemies[j];
                const dx = e1.x - e2.x;
                const dy = e1.y - e2.y;
                const dist = Math.hypot(dx, dy);
                const minDist = (e1.size + e2.size) * 0.9; 
                if (dist < minDist && dist > 0) {
                    const overlap = minDist - dist;
                    const pushX = (dx / dist) * (overlap / 2);
                    const pushY = (dy / dist) * (overlap / 2);
                    e1.x += pushX * 0.5;
                    e1.y += pushY * 0.5;
                    e2.x -= pushX * 0.5;
                    e2.y -= pushY * 0.5;
                }
            }
        }
    }

    function update(dt) {
        if(isGameOver || isLevelUp) return;

        // Player Move
        if(keys.w && player.y > player.size) player.y -= PLAYER_SPEED;
        if(keys.s && player.y < GAME_HEIGHT - player.size) player.y += PLAYER_SPEED;
        if(keys.a && player.x > player.size) player.x -= PLAYER_SPEED;
        if(keys.d && player.x < GAME_WIDTH - player.size) player.x += PLAYER_SPEED;

        if(upgradeLevels.regen > 0) {
            const regenAmount = (upgradeLevels.regen * 0.5) * (dt / 1000);
            // 最大HPを超えないように回復
            if (player.hp < player.maxHp) {
                player.hp += regenAmount;
                if (player.hp > player.maxHp) player.hp = player.maxHp;
                updateHpUI(); // UIを更新して数値に反映させる
            }
        }

        updateDice(dt);
        updateWave(dt);

        enemies.forEach(e => e.update(dt));
        resolveEnemyCollisions();

        // Projectiles update
        projectiles.forEach((m, i) => {
            m.update();
            if(m.life <= 0 || m.x < -100 || m.x > GAME_WIDTH+100 || m.y < -100 || m.y > GAME_HEIGHT+100) {
                projectiles.splice(i, 1);
            } else {
                // Hit check
                for(let j=enemies.length-1; j>=0; j--) {
                    const e = enemies[j];
                    const dist = Math.hypot(m.x - e.x, m.y - e.y);
                    
                    if(dist < e.size + m.size) {
                        
                        // --- ミサイル (爆風) ---
                        if(m.type === 'missile') {
                            createMissileExplosion(m.x, m.y);
                            
                            // ★変更: 爆発範囲アップグレード適用
                            const missileLv = upgradeLevels.missile_ex || 0;
                            // 基本80 * (1 + Lv*0.15)
                            const blastRadius = 80 * (1 + missileLv * 0.15);
                            
                            enemies.forEach(subE => {
                                const blastDist = Math.hypot(m.x - subE.x, m.y - subE.y);
                                if(blastDist < blastRadius) {
                                    subE.hp -= getDamage(4);
                                    if(subE.hp <= 0) subE.dead = true;
                                }
                            });
                            projectiles.splice(i, 1);
                            break; 
                        }
                        
                        // --- ドローン (範囲持続) ---
                        else if(m.type === 'drone') {
                            // (変更なし)
                            const alreadyHit = m.hitCooldowns.find(h => h.enemy === e);
                            if(alreadyHit) continue; 
                            m.hitCooldowns.push({ enemy: e, timer: 15 });
                            e.hp -= getDamage(4);
                            createExplosion(m.x, m.y);
                            if(e.hp <= 0) e.dead = true;
                            break;
                        }
                        
                        // --- マシンガン (貫通強化) ---
                        else if(m.type === 'machinegun') {
                            if(m.hitEnemies.includes(e)) continue;

                            e.hp -= getDamage(4); 
                            createExplosion(m.x, m.y);
                            if(e.hp <= 0) e.dead = true;

                            m.hitEnemies.push(e);
                            
                            // ★変更: 貫通数アップグレード適用
                            // 基本2ヒット + アップグレードLv
                            const pierceBonus = upgradeLevels.mg_pierce || 0;
                            const maxHits = 2 + pierceBonus;

                            if(m.hitEnemies.length >= maxHits) {
                                projectiles.splice(i, 1);
                                break;
                            }
                            break; 
                        }

                        // --- その他 ---
                        else {
                            e.hp -= getDamage(4);
                            createExplosion(m.x, m.y);
                            projectiles.splice(i, 1);
                            if(e.hp <= 0) e.dead = true;
                            break;
                        }
                    }
                }
            }
        });

        // Area Effects update
        areaEffects.forEach((a, i) => {
            a.update(dt);
            if(a.type === 'shockwave' && a.timer >= a.duration) areaEffects.splice(i, 1);
            else if(a.type === 'gravity' && a.timer >= a.duration) areaEffects.splice(i, 1);
        });

        // Dead enemies cleanup
        for(let i=enemies.length-1; i>=0; i--) {
            if(enemies[i].dead) {
                if(enemies[i].isBoss) {
                    diceDrops.push(new DiceDrop(enemies[i].x, enemies[i].y));
                    spawnGems(enemies[i].x, enemies[i].y, 1000); 
                    for(let k=0; k<5; k++) createExplosion(enemies[i].x + (Math.random()-0.5)*40, enemies[i].y + (Math.random()-0.5)*40);
                } else {
                    // ★修正: noGemフラグがなければジェムを落とす
                    if (!enemies[i].noGem) {
                        const xpAmount = Math.max(1, Math.floor(enemies[i].maxHp * 0.8));
                        spawnGems(enemies[i].x, enemies[i].y, xpAmount);
                    }
                }
                enemies.splice(i, 1);
            }
        }

        // Jewels update
        jewels.forEach((j, i) => {
            j.update();
            const dist = Math.hypot(player.x - j.x, player.y - j.y);
            if(dist < player.size + j.size + 2) {
                gainXp(j.xp);
                jewels.splice(i, 1);
            }
        });

        // DiceDrops update
        diceDrops.forEach((d, i) => {
            d.update();
            const dist = Math.hypot(player.x - d.x, player.y - d.y);
            if(dist < player.size + d.size + 2) {
                gainDice();
                diceDrops.splice(i, 1);
            }
        });

        particles.forEach((p, i) => {
            p.update();
            if(p.life <= 0) particles.splice(i, 1);
        });

        for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
            const ep = enemyProjectiles[i];
            ep.update();
            
            // 画面外削除
            if (ep.x < -50 || ep.x > GAME_WIDTH + 50 || ep.y < -50 || ep.y > GAME_HEIGHT + 50 || ep.life <= 0) {
                enemyProjectiles.splice(i, 1);
                continue;
            }

            // プレイヤーとの衝突
            const dist = Math.hypot(player.x - ep.x, player.y - ep.y);
            if (dist < player.size + ep.size) {
                player.hp -= 10; // 弾のダメージ
                enemyProjectiles.splice(i, 1);
                updateHpUI();
                
                // ゲームオーバー判定はこの後の共通処理に任せるか、ここで書く
                // ★追加: ここでゲームオーバー判定を行う
                if(player.hp <= 0) {
                    triggerGameOver();
                }
            }
        }

        // Player Damage
        let isTakingDamage = false;
        for(let e of enemies) {
            const dist = Math.hypot(player.x - e.x, player.y - e.y);
            if(dist < player.size + e.size) {
                isTakingDamage = true;
                const damage = e.dps * (dt / 1000);
                player.hp -= damage;
            }
        }
        if(isTakingDamage) {
            updateHpUI(); // HPバー更新
            
            // ★修正: 関数呼び出しに変更
            if(player.hp <= 0) {
                triggerGameOver();
            }
        }
    }

    function draw() {
        ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        // Grid
        ctx.strokeStyle = '#222';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for(let x=0; x<GAME_WIDTH; x+=60) { ctx.moveTo(x,0); ctx.lineTo(x, GAME_HEIGHT); }
        for(let y=0; y<GAME_HEIGHT; y+=60) { ctx.moveTo(0,y); ctx.lineTo(GAME_WIDTH, y); }
        ctx.stroke();

        areaEffects.forEach(a => a.draw());
        jewels.forEach(j => j.draw());
        diceDrops.forEach(d => d.draw()); // ★追加: ダイスの描画
        enemies.forEach(e => e.draw());
        enemyProjectiles.forEach(ep => ep.draw());
        projectiles.forEach(m => m.draw());
        particles.forEach(p => p.draw());

        // Player
        ctx.shadowBlur = 10;
        ctx.shadowColor = player.color;
        ctx.fillStyle = player.color;
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.size, 0, Math.PI*2);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.size + 4, 0, Math.PI*2);
        ctx.stroke();
    }

    function gameLoop(timestamp) {
        if(!isGameRunning) return; // タイトル画面等ではループ停止

        animationFrameId = requestAnimationFrame(gameLoop);

        if(isPaused) return;

        let dt = timestamp - lastTime;
        if(dt > 100) dt = 16; 
        lastTime = timestamp;

        update(dt);
        draw();
    }

    function init() {
        // 最初はタイトルを表示
        showTitle();
    }



    // --- シーン管理 ---

    function showTitle() {
        // ゲーム停止
        isGameRunning = false;
        isPaused = false;
        isGameOver = false;
        
        // 画面切り替え
        document.getElementById('title-screen').style.display = 'flex';
        screenGameOver.style.display = 'none';
        screenPause.style.display = 'none';
        screenLevelUp.style.display = 'none';

        // クレジット表示更新
        const cr = parseInt(localStorage.getItem('diceSurvivors_credits')) || 0;
        document.getElementById('title-credits').innerText = cr;

        // 背景用に一度だけ描画（真っ黒にならないように）
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
    }

    function openShop() {
        document.getElementById('title-screen').style.display = 'none';
        document.getElementById('shop-screen').style.display = 'flex';
        renderShop();
    }

    function closeShop() {
        document.getElementById('shop-screen').style.display = 'none';
        showTitle();
    }

    function renderShop() {
        // クレジット表示更新
        document.getElementById('shop-credits-display').innerText = totalCredits;

        const container = document.getElementById('shop-container');
        container.innerHTML = '';

        Object.values(UPGRADE_CONFIG).forEach(item => {
            const currentLv = upgradeLevels[item.id] || 0;
            const isMax = currentLv >= item.maxLevel;
            const nextCost = isMax ? 0 : item.costs[currentLv];
            const canAfford = totalCredits >= nextCost;

            const card = document.createElement('div');
            card.className = 'shop-card';
            card.innerHTML = `
                <div class="shop-card-header">
                    <span class="shop-item-name">${item.name}</span>
                    <span class="shop-item-level">Lv.${currentLv} / ${item.maxLevel}</span>
                </div>
                <div class="shop-item-desc">${item.desc}</div>
                <button class="shop-buy-btn" onclick="buyUpgrade('${item.id}')" ${isMax || !canAfford ? 'disabled' : ''}>
                    <span>${isMax ? 'SOLD OUT' : 'BUY'}</span>
                    <span class="shop-cost">${isMax ? '' : nextCost} CR</span>
                </button>
            `;
            container.appendChild(card);
        });

        
    }

    // ★追加: 全額払い戻し機能
    function refundUpgrades() {
        if(!confirm("全てのアップグレードを解除して、クレジットを払い戻しますか？")) return;

        let refundTotal = 0;

        // 全アップグレード項目を走査
        Object.keys(UPGRADE_CONFIG).forEach(key => {
            const item = UPGRADE_CONFIG[key];
            const currentLevel = upgradeLevels[key] || 0;
            
            // 現在のレベルに至るまでにかかったコストを合算
            for(let i=0; i < currentLevel; i++) {
                refundTotal += item.costs[i];
            }
            
            // レベルをリセット
            upgradeLevels[key] = 0;
        });

        // クレジット返却
        totalCredits += refundTotal;

        // 保存
        localStorage.setItem('diceSurvivors_credits', totalCredits);
        localStorage.setItem('diceSurvivors_upgrades', JSON.stringify(upgradeLevels));

        // 画面更新
        renderShop();
        alert(`${refundTotal} クレジットが払い戻されました。`);
    }

    function buyUpgrade(id) {
        const item = UPGRADE_CONFIG[id];
        const currentLv = upgradeLevels[id] || 0;
        
        if(currentLv >= item.maxLevel) return;

        const cost = item.costs[currentLv];
        if(totalCredits >= cost) {
            // 購入処理
            totalCredits -= cost;
            upgradeLevels[id] = currentLv + 1;
            
            // 保存
            localStorage.setItem('diceSurvivors_credits', totalCredits);
            localStorage.setItem('diceSurvivors_upgrades', JSON.stringify(upgradeLevels));
            
            // 再描画
            renderShop();
        }
    }

    function resetGame() {
        // 変数初期化
        level = 1;
        currentXp = 0;
        nextLevelXp = 50;
        wave = 1;
        score = 0;
        diceTimer = 0;
        waveTimer = 0;
        lastTime = performance.now();
        
        // ★変更: HPアップグレード反映 (Base 100 + Lv * 20)
        const bonusHp = (upgradeLevels.hp || 0) * 20;
        player.maxHp = 100 + bonusHp;
        player.hp = player.maxHp;
        player.x = GAME_WIDTH / 2;
        player.y = GAME_HEIGHT / 2;

        enemies = [];
        projectiles = [];
        enemyProjectiles = []; // ★追加: 初期化
        particles = [];
        jewels = [];
        diceDrops = [];
        areaEffects = [];

        // ダイススロット初期化
        diceSlots = [
            { type: 'missile', level: 1 },
            { type: 'missile', level: 2 },
            { type: 'missile', level: 3 },
            { type: 'missile', level: 4 },
            { type: 'missile', level: 5 },
            { type: 'missile', level: 6 }
        ];

        // UI初期化
        initUI();
        
        // ★変更: 初期ダイス数反映 (Base 1 + Upgrade)
        const container = document.getElementById('dice-container');
        container.innerHTML = '';
        
        const initialDiceCount = 1 + (upgradeLevels.dice || 0); // アップグレード分追加
        
        for(let i=0; i<initialDiceCount; i++) {
            const newDice = document.createElement('div');
            newDice.className = 'dice face-1';
            newDice.id = `dice-${i}`;
            newDice.innerHTML = '<div class="pip"></div>';
            container.appendChild(newDice);
        }
        refreshDiceList();

        spawnEnemyBatch();
    }

    // ★追加: 攻撃力アップグレード適用後のダメージ計算
    function getDamage(baseDamage) {
        const multiplier = 1 + (upgradeLevels.atk || 0) * 0.1; // Lv * 10%
        return baseDamage * multiplier;
    }

    function startGame() {
        document.getElementById('title-screen').style.display = 'none';
        resetGame();
        isGameRunning = true;
        isGameOver = false;
        lastTime = performance.now();
        
        if(animationFrameId) cancelAnimationFrame(animationFrameId);
        gameLoop(performance.now());
    }

    // ★追加: ゲームオーバー共通処理
    function triggerGameOver() {
        if(isGameOver) return; // 二重発動防止
        
        player.hp = 0;
        isGameOver = true;

        // スコア保存処理
        if(score > highScore) {
            highScore = score;
            localStorage.setItem('diceSurvivors_highScore', highScore);
        }
        
        // クレジット加算と保存
        totalCredits += score;
        localStorage.setItem('diceSurvivors_credits', totalCredits);

        // UIへの反映
        document.getElementById('go-score').innerText = score;
        document.getElementById('go-high-score').innerText = highScore;
        document.getElementById('go-credits').innerText = score;

        screenGameOver.style.display = 'flex';
    }

    function backToTitle() {
        // ゲームオーバー画面などからタイトルへ
        showTitle();
    }

    

    init();

</script>
</body>
</html>